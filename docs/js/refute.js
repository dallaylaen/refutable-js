(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
'use strict';

// TODO this has nothing to do with refute and should be a separate package

/*
 *  These classes describe a tree-like structure consisting of (indented)
 *  strings representing actual and expected values and their context.
 *  A cross between TAP and diff(1) output.
 */

/*
 *  Base class for DiffContent & DiffTree
 */
class Renderable {
    constructor() {} // pass
    render() {
        throw new Error('render() unimplemented in subclass');
        // return 'a string';
    }
}

/**
 *   DiffTree is a class that represents a nested indented
 *   collection of actual/expected lines.
 */

class DiffTree extends Renderable {
    constructor() {
        super();
        this._log = [];
    }
    append (msg) {
        if (!(msg instanceof Renderable))
            throw new Error('DiffTree entry must be a Renderable');
        this._log.push(msg);
        return this;
    }
    render(format, indent=0) {
        return this._log.map( x=>x.render(format, indent+1) ).join('');
    };
}

/*
 *  Another abstract class - an actual line of diff information.
 *  Requires predefined metainformation to function correctly.
 */

class DiffLine extends Renderable {
    constructor( text, meta ) {
        super();
        this._text = text;
        this._meta = meta;
    }
    toString() {
        return this._meta.prefix + this._text;
    }
    render(format={}, indent=1) {
        // TODO actually utilize format
        return '    '.repeat(indent-1)+this._meta.prefix + this._text + '\n';
    }
}

const DIFF_CONTENT_TYPES = {
    actual: {
        level: 3,
        prefix: '- ',
        color: 'red',
    },
    expected: {
        level: 3,
        prefix: '+ ',
        color: 'green',
    },
    location: {
        level: 3,
        prefix: 'at ', // TODO @
        color: 'gray',
    },
    context: {
        level: 3,
        prefix: '  ',
        color: 'gray',
    },
    note: {
        level: 7,
        prefix: '',
        color: 'gray',
    },
};
for( let name in DIFF_CONTENT_TYPES )
    DIFF_CONTENT_TYPES[name].name=name;

class DiffContent extends DiffLine {
    constructor( text, type ) {
        if (!DIFF_CONTENT_TYPES[type])
            throw new Error('Unknown DiffContent type: '+type);

        super( text, DIFF_CONTENT_TYPES[type] );
    }
}

const DIFF_CHECK_TYPES = {
    pass: {
        level: 2,
        prefix: 'ok ',
        color: 'green',
    },
    fail: {
        level: 1,
        prefix: '!fail ',
        color: 'red',
    },
    plan: {
        level: 1,
        prefix: 'plan ', // TODO better
        color: 'green',
    },
};
for( let name in DIFF_CHECK_TYPES )
    DIFF_CHECK_TYPES[name].name=name;

// TODO better name!!
// TODO this is a copypaste of DiffContent, unify better
class DiffCheck extends DiffLine {
    constructor( text, type ) {
        if (!DIFF_CHECK_TYPES[type])
            throw new Error('Unknown DiffContent type: '+type);

        super( text, DIFF_CHECK_TYPES[type] );
    }
}

const out = { Renderable, DiffTree, DiffLine, DiffContent };

Object.keys( DIFF_CONTENT_TYPES ).forEach( i => out[i] = msg => new DiffContent (msg, i));
Object.keys( DIFF_CHECK_TYPES ).forEach( i => out[i] = msg => new DiffCheck (msg, i));

out.log = () => new DiffTree();

module.exports = out;

},{}],2:[function(require,module,exports){
'use strict';

// the core (should explain even be there?)
const { Report, addCondition, explain } = require ('./refute/report.js');

// eiffel-style design-by-contract
const { DBC } = require( './refute/dbc.js' );

// import default condition arsenal
require( './refute/cond/basic.js' );
require( './refute/cond/array.js' );
require( './refute/cond/deep.js' );

const getReport = (...args) => new Report().run(...args).done();

// Allow creating multiple parallel configurations of refute
// e.g. one strict (throwing errors) and other lax (just debugging to console)
function setup( options={}, orig ) {
    // TODO validate options
    const onFail = options.onFail || (rep => { throw new Error(rep.getTap()) });

    const refute = options.skip
        ? ()=>{}
        : (...args) => {
            const ok = new Report();
            ok.onDone( x => { if( !x.getPass() ) onFail(x, args) } );
            ok.run(...args);
            ok.done();
        };

    // reexport all from report.js
    refute.Report = Report;
    refute.explain = explain;
    refute.addCondition = addCondition;

    // shortcut to validating & returning a fresh contract
    // TODO rename to avoid name clash with the class
    // (eval?)
    refute.report = getReport;

    // refute.conf({...}) will generate a _new_ refute
    refute.config = update => setup( { ...options, ...update }, refute );

    // add design-by-contract
    Object.defineProperty( refute, 'dbc', { get: ()=>new DBC() } );

    // TODO this is stupid, come up with smth better
    // when in browser, window.refute.config() updates window.refute itself
    if (typeof window !== 'undefined' && orig === window.refute)
        window.refute = refute;

    return refute;
}

if (typeof module !== 'undefined')
    module.exports = setup();
if (typeof window !== 'undefined')
    window.refute = setup(); // TODO check preexisting

/**
 *   @callback Contract
 *   @desc A code block containing one or more condition checks.
 *   A check is performed by calling one of a few special methods
 *   (equal, match, deepEqual, type etc)
 *   on the Report object.
 *   Contracts may be nested using the 'nested' method which accepts
 *   another contract and records a pass/failure in the parent accordingly.q
 *   A contract is always executed to the end.
 *   @param {Report} ok An object that records check results.
 *   @param {Any} [...list] Additional parameters
 *   (e.g. data structure to be validated)
 *   @returns {void} Returned value is ignored.
 */

/**
 *   @public
 *   @function refute
 *   @param {Any} [...list] Data to feed to the callback
 *   @param {Contract} contract A code block with checks.
 *   @returns {undefined} Return value is ignored.
 *   @throws {Error} If one or more checks are failing, an exception is thrown
 *   with details about all passing/failing checks.
 *   This action can be changed via refute.config() call.
 *
 */


},{"./refute/cond/array.js":3,"./refute/cond/basic.js":4,"./refute/cond/deep.js":5,"./refute/dbc.js":6,"./refute/report.js":7}],3:[function(require,module,exports){
'use strict';

const { addCondition, Report } = require( '../report.js' );

// TODO rename forEach or smth.
addCondition(
    'map',
    {fun:1,args:2},
    (list, contract) => {
        if (!Array.isArray(list))
            return 'Expected a list, found a '.typeof(list);
        if (list.length < 1)
            return 0; // auto-pass

        const ok = new Report();
        list.forEach( (item, index) => ok.nested( "item "+index, item, contract ) );
        return ok.done();
    }
);

// TODO this is called "compliant chain" but better just say here
// "oh we're checking element order"
addCondition(
    'ordered', // TODO better name?
    {fun:1,args:2},
    (list, contract) => {
        if (!Array.isArray(list))
            return 'Expected a list, found a '.typeof(list);
        if (list.length < 2)
            return 0; // auto-pass

        const ok = new Report();
        for (let n = 0; n < list.length-1; n++) {
            ok.nested( "items "+n+", "+(n+1), list[n], list[n+1], contract);
        }
        return ok.done();
    }
);


},{"../report.js":7}],4:[function(require,module,exports){
'use strict';

const { addCondition, report, explain, log } = require( '../report.js' );
const OK = false;

const numCmp = {
    '<' : (x,y)=>(x  < y),
    '>' : (x,y)=>(x  > y),
    '<=': (x,y)=>(x <= y),
    '>=': (x,y)=>(x >= y),
    '==': (x,y)=>(x === y),
    '!=': (x,y)=>(x !== y),
};

// use != and not !== deliberately to filter out null & undefined
const strCmp = {
    '<' : (x,y)=>x != undefined && y != undefined && (''+x  < ''+y),
    '>' : (x,y)=>x != undefined && y != undefined && (''+x  > ''+y),
    '<=': (x,y)=>x != undefined && y != undefined && (''+x <= ''+y),
    '>=': (x,y)=>x != undefined && y != undefined && (''+x >= ''+y),

    '==': (x,y)=>x != undefined && y != undefined && (''+x === ''+y),
    '!=': (x,y)=>((x == undefined)^(y == undefined)) || (''+x !== ''+y),
};

addCondition(
    'numCmp',
    {args:3},
    (x,op,y) => numCmp[op](x,y)?0:[explain(x),"is not "+op,explain(y)]
);
addCondition(
    'strCmp',
    {args:3},
    (x,op,y) => strCmp[op](x,y)?0:[explain(x),"is not "+op,explain(y)]
);

const typeCheck = {
    undefined: x => x === undefined,
    null:      x => x === null,
    number:    x => typeof x === 'number' && !Number.isNaN(x),
    integer:   x => Number.isInteger(x),
    nan:       x => Number.isNaN(x),
    string:    x => typeof x === 'string',
    function:  x => typeof x === 'function',
    boolean:   x => typeof x === 'boolean',
    object:    x => x && typeof x === 'object' && !Array.isArray(x),
    array:     x => Array.isArray(x),
};
function typeExplain (x) {
    if (typeof x === 'string')
        return x;
    if (typeof x === 'function')
        return 'instanceof '+(x.name || x);
};

addCondition(
    'type',
    {args: 2},
    (got, exp)=>{
        if ( !Array.isArray(exp) )
            exp = [exp];

        for (let variant of exp) {
            // known type
            if( typeof variant === 'string' && typeCheck[variant] ) {
                if (typeCheck[variant](got))
                    return OK;
                continue;
            };

            // instanceof
            if( typeof variant === 'function' && typeof got === 'object') {
                if( got instanceof variant )
                    return OK;
                continue;
            };

            // don't know what you're asking for
            return 'unknown value type spec: '+explain(variant, 1);
        };
        return [
            log.got(explain(got, 1)),
            log.exp(exp.map( typeExplain ).join(" or ")),
        ];
    }
);


},{"../report.js":7}],5:[function(require,module,exports){
'use strict';

const { addCondition, explain, log } = require( '../report.js' );
const { AnnotatedSet } = require( '../util/annotated-set.js' );

addCondition( 'deepEqual', {"args":2,hasOptions:true}, deep );

function deep( got, exp, options={} ) {
    if (!options.max)
        options.max = 5;
    options.diff = [];
    _deep( got, exp, options );
    if (!options.diff.length)
        return 0;

    const ret = [];
    for (let item of options.diff) {
        ret.push( 
            log.loc(item[0]),
            log.got(item[3] ? item[1] : explain( item[1], 2 )),
            log.exp(item[3] ? item[2] : explain( item[2], 2 )),
        );
    };
    return ret;
};

// result is stored in options.diff=[], return value is ignored
// if said diff exceeds max, return immediately & don't waste time
function _deep( got, exp, options={}, path='$', seenL=new AnnotatedSet(), seenR=new AnnotatedSet() ) {
    if (got === exp || options.max <= options.diff.length)
        return;
    if (typeof got !== typeof exp)
        return options.diff.push( [path, got, exp ] );

    // recurse by expected value - consider it more predictable
    if (typeof exp !== 'object' || exp === null ) {
        // non-objects - so can't descend
        // and comparison already done at the beginnning
        return options.diff.push( [path, got, exp ] );
    }

    // must detect loops before going down
    const pathL = seenL.has(got);
    const pathR = seenR.has(exp);
    if (pathL || pathR) {
        // Loop detected = only check topology
        if (pathL === pathR)
            return;
        return options.diff.push( [
            path + ' (circular)',
            pathL ? 'Circular='+pathL : explain(got, 2),
            pathR ? 'Circular='+pathR : explain(exp, 2),
            true // don't stringify
        ]);
    };
    seenL = seenL.add(got, path);
    seenR = seenR.add(exp, path);

    // compare object types
    // (if a user is stupid enough to override constructor field, well the test
    // would fail later anyway)
    if (got.constructor !== exp.constructor)
        return options.diff.push( [path, got, exp ] );

    // array
    if (Array.isArray(exp)) {
        if (!Array.isArray(got) || got.length !== exp.length)
            return options.diff.push( [path, got, exp ] );

        for (let i = 0; i < exp.length; i++) {
            _deep( got[i], exp[i], options, path+'['+i+']', seenL, seenR );
            if (options.max<=options.diff.length)
                break;
        };
        return;
    };

    // compare keys - +1 for exp, -1 for got, nonzero key at end means keys differ
    const uniq = {};
    Object.keys(exp).forEach( x => uniq[x] = 1 );
    Object.keys(got).forEach( x => uniq[x] = (uniq[x] || 0) - 1 );
    for (let x in uniq) {
        if (uniq[x] !== 0)
            return options.diff.push( [path, got, exp ] );
    }
    
    // now typeof, object type, and object keys are the same.
    // recurse.
    for (let i in exp) {
        _deep( got[i], exp[i], options, path+'['+explain(i)+']', seenL, seenR );
        if (options.max<=options.diff.length)
            break;
    };
    return;
};


},{"../report.js":7,"../util/annotated-set.js":9}],6:[function(require,module,exports){
'use strict';

const { Report } = require ( './report.js' );
const noop = ()=>{};

class DBC {
    constructor() {
        this._pre    = noop;
        this._post   = noop;
        this._onfail = report => report.getThrown();
        this._onpost = undefined;
    }
    post(code) {
        if (code === undefined) {
            return this._post;
        } else {
            if( typeof code !== 'function' )
                throw new Error('post-condition must be a function');
            this._post = code;
            return this;
        }
    }
    pre(code) {
        if (code === undefined) {
            return this._pre;
        } else {
            if( typeof code !== 'function' )
                throw new Error('pre-condition must be a function');
            this._pre = code;
            return this;
        }
    }
    decorate(orig) {
        // close around these vars
        const pre    = this._pre;
        const post   = this._post;
        const onfail = this._onfail;
        const onpost = this._onpost || this._onfail;

        // no arrow function to get correct 'this' object
        const code = function (...args) {
            const rPre = new Report();
            pre.apply( this, [ rPre, undefined, ...args ] );
            if(!rPre.getPass())
                onfail(rPre.setTitle('pre-condition failed'));
            const ret = orig.apply( this, args );
            const rPost = new Report();
            post.apply( this, [ rPost, ret, ...args ] );
            if(!rPost.getPass())
                onpost(rPost.setTitle('post-condition failed'));
            return ret;
        }

        code.orig = orig;
        code.pre  = pre;
        code.post = post;

        return code;
    }
}

module.exports = { DBC };

},{"./report.js":7}],7:[function(require,module,exports){
'use strict';

const { callerInfo, explain, makeError } = require( './util.js' );
const dt = require( '../diff-tree.js' ); // TODO should be external package

// TODO better names, and diff-tree should export those from the start
const log = {
    got: dt.actual,
    exp: dt.expected,
    ctx: dt.context,
    loc: dt.location,
    note: dt.note,
};

/**
 * @public
 * @classdesc
 * The core of the refute library, the report object contains info
 * about passing and failing conditions.
 */
class Report {
    // setup
    constructor() {
        this._count     = 0;
        this._failCount = 0;
        this._descr     = [];
        this._evidence  = [];
        this._where     = [];
        this._condName  = [];
        this._info      = [];
        this._nested    = [];
        this._pending   = new Set();
        this._onDone    = [];
        this._done      = false;
        // TODO add caller info about the report itself
    }

    // setup - must be chainable
    setTitle(str) {
        this._title = str;
        return this;
    };

    onDone(fn) {
        this._onDone.push(fn);
        return this;
    };

    // running
    // TODO either async() should support additional args, or run() shouldn't
    run(...args) {
        this._lock();
        const block = args.pop();
        if (typeof block !== 'function')
            throw new Error('Last argument of run() must be a function, not '+typeof(block));
        block( this, ...args );
        return this;
    }

    // TODO either async() should support additional args, or run() shouldn't
    async(timeout, block) {
        return new Promise( (resolve, reject) => {
            const timer = setTimeout(
                () => reject(new Error("Contract execution took too long")),
                timeout
            );
            this.onDone(arg => {clearTimeout(timer); resolve(arg)});
            block(this);
        });
    }

    // In theory, having const n=next(); setResult(n. ...)
    // should allow for async conditions in the future
    // if at all possible without great sacrifices.
    next() {
        this._lock();
        return ++this._count;
    }

    setResult (n, evidence, descr, condName, where) {
        if(!this._pending.has(n))
            this._lock();
        this._pending.delete(n);
        if (n > this._count)
            throw new Error ('Attempt to set condition beyond check count');
        if (descr)
            this._descr[n] = descr;
        // pass - return ASAP
        if (!evidence)
            return;

        // nested report needs special handling
        if (evidence instanceof Report) {
            this._nested[n] = evidence;
            if (evidence.getDone()) {
                if (evidence.getPass())
                    return; // short-circuit if possible
                evidence = []; // hack - failing without explanation
            } else {
                // nested contract is in async mode - coerce into a promise
                const curry = evidence;
                evidence = new Promise( done => {
                    curry.onDone( done );
                });
            }
        }

        // pending - we're in async mode
        if (evidence instanceof Promise) {
            this._pending.add(n);
            where = where || callerInfo(2); // must report actual caller, not then
            evidence.then( x => {
                this.setResult(n, x, descr, condName, where );
                if (this.getDone()) {
                    for (let cb of this._onDone)
                        cb(this);
                }
            });
            return;
        }

        // coerce evidence into a list of diff-tree objects
        if (!Array.isArray(evidence))
            evidence = [ evidence ];
        this._evidence[n] = evidence.map(
            x=>x instanceof dt.DiffContent ? x : log.note( _explain(x, Infinity) ) );
        this._where[n]    = where || callerInfo(2);
        this._condName[n] = condName;
        this._failCount++;

        return;
    }

    /**
     * @desc Append an informational message to the report.
     * Non-string values will be stringified via explain().
     * @param {Any} message
     * @returns {Report} chainable
     */
    info( ...message ) {
        this._lock();
        if (!this._info[this._count])
            this._info[this._count] = [];
        this._info[this._count].push( log.note( message.map( s=>_explain(s) ).join(" ") ) );
        return this;
    }

    done() {
        if (!this._done) {
            this._done = true;
            if (!this._pending.size) {
                for (let cb of this._onDone)
                    cb(this);
            }
        };
        return this;
    }

    // querying
    getTitle() {
        return this._title; //JFYI
    };

    /**
     *   @returns {boolean}
     */
    getDone() {
        return this._done && !this._pending.size; // is it even needed?
    }

    _lock () {
        if (this._done)
            throw new Error('Attempt to modify a finished contract');
    }

    /**
     *   @desc Without argument returns whether the contract was fulfilled.
     *   As a special case, if no checks were run and the contract is finished,
     *   returns false, as in "someone must have forgotten to execute
     *   planned checks. Use pass() if no checks are planned.
     *
     *   If a parameter is given, return the status of n-th check instead.
     *   @param {integer} n
     *   @returns {boolean}
     */
    getPass(n) {
        if (n === undefined)
            return this._failCount === 0 && (!this.getDone() || this._count > 0);
        return (n > 0 && n <= this._count) ? !this._evidence[n] : undefined;
    }

    /**
     *   @desc Number of checks performed.
     *   @returns {number}
     */
    getCount() {
        return this._count;
    }

    /**
     *  @desc Whether the last check was a success.
     *  This is just a shortcut for foo.getDetails(foo.getCount).pass
     *  @returns {boolean}
     */
    last() {
        return this._count ? !this._evidence[this._count] : undefined;
    }

    /**
     *   @desc Number of checks failing.
     *   @returns {number}
     */
    getFailCount() {
        return this._failCount;
    }

    /**
     *   @desc Return a string of failing/passing checks.
     *   This may be useful for validating custom conditions.
     *   Consecutive passing checka are represented by numbers.
     *   A capital letter in the string represents failure.
     *   @returns {string}
     *   @example
     *   // 10 passing checks
     *   "r(10)"
     *   @example
     *   // 10 checks with 1 failure in the middle
     *   "r(5,N,4)"
     *   @example
     *   // 10 checks including a nested contract
     *   "r(3,r(1,N),6)"
     *   @example
     *   // no checks were run - auto-fail
     *   "r(Z)"
     */
    getGhost() {
        const ghost = [];
        let streak = 0;
        for (let i=1; i <= this._count; i++) {
            if (this._evidence[i] || this._nested[i]) {
                if (streak) ghost.push(streak);
                streak = 0;
                ghost.push( this._nested[i] ? this._nested[i].getGhost() : 'N');
            } else {
                streak++;
            }
        }
        if (streak) ghost.push(streak);
        if (ghost.length === 0 && !this.getPass())
            ghost.push('Z');
        return 'r('+ghost.join(',')+')';
    }

    /**
     *  @desc returns a plain serializable object
     *  @returns {Object}
     */
    toJSON() {
        const n = this.getCount();
        const details = [];
        for (let i = 0; i<=n; i++) {
            const node = this.getDetails(i);
            // strip extra keys
            for( let key in node ) {
                if (node[key] === undefined || (Array.isArray(node[key]) && node[key].length === 0))
                    delete node[key];
            };
            details.push(node);
        };
        return {
            pass:  this.getPass(),
            count: this.getCount(),
            title: this.getTitle(),
            details,
        };
    }

    toString() {
        return this.getTap();
    }

    /**
     *  @desc Returns report stringified as TAP format
     *  @returns {string}
     */
    getTap(n) {
        const tap = n === undefined ? this.getTapLines() : this.getTapEntry(n);
        tap.push('');
        return tap.join('\n');
    }

    getTapLines(n) {
        // TAP for now, use another format later because "perl is scary"
        const tap = [ '1..'+this._count ];
        if (this.getTitle())
            tap.push('# '+this.getTitle());
        // TODO info[0]
        const preface = this.getDetails(0);
        tap.push( ...preface.info.map( s => '# '+s ) );
        for( let i = 1; i <= this._count; i++ )
            tap.push( ... this.getTapEntry(i) );
        if (!this.getPass()) {
            if (this.getCount() > 0)
                tap.push('# Failed '+this.getFailCount()+'/'+this.getCount()+ ' conditions');
            else
                tap.push('# No checks were run, consider using pass() if that\'s deliberate');
        };
        return tap;
    }

    getTapEntry(n) {
        const data = typeof(n) === 'object' ? n : this.getDetails(n);
        const tap = [];
        if (data.nested) {
            tap.push( '# subcontract:'+(data.name?' '+data.name:'') );
            tap.push( ... data.nested.getTapLines().map( s => '    '+s ));
        }
        if (data.pending) {
            tap.push( 'pending '+data.n+' <...>' );
            return tap;
        }
        tap.push((data.pass?'':'not ') + 'ok ' + data.n
            + (data.name ? ' - '+data.name : ''));
        if (!data.pass)
            tap.push('# Condition'+(data.cond ? ' '+data.cond : '')+' failed at '+data.where);
        tap.push(...data.evidence.map(s=>'# '+s));
        tap.push(...data.info.map(s=>'# '+s));
        return tap;
    }

    /**
     *   @desc Returns detailed report on a specific check
     *   @param {integer} n - check number, must be <= getCount()
     *   @returns {object}
     */
    getDetails(n) {
        // TODO validate n

        // ugly but what can I do
        if (n === 0) {
            return {
                n:    0,
                info: this._info[0] || [],
            };
        }

        let evidence = this._evidence[n];
        if (evidence && !Array.isArray(evidence))
            evidence = [evidence];

        return {
            n:        n,
            name:     this._descr[n] || '',
            pass:     !evidence,
            evidence: evidence || [],
            where:    this._where[n],
            cond:     this._condName[n],
            info:     this._info[n] || [],
            nested:   this._nested[n],
            pending:  this._pending.has(n),
        };
    }

    /**
     *  @desc Convert report to an AssertionError (if available) or just Error.
     *  @param {number} [n] Number of check to convert to exception.
     *  Current error format is TAP, this may change in the future.
     *  If 0 or unspecified, convert the whole report.
     *  @param {object} [options]
     *  @param {boolean} options.pass If false (the default), return nothing
     *  if the report is passing.
     *  @returns {Error|undefined}
     */
    getError(n, options={}) {
        if (!n) {
            // no entry given
            if (!options.pass && this.getPass())
                return;

            return makeError({
                actual:   this.getTap(),
                expected: '',
                message:  this.getTitle(),
                operator: 'contract',
            });
        };

        const data = typeof n === 'object' ? n : this.getDetails(n);

        // no error
        if (!options.pass && data.pass)
            return;

        return makeError({
            actual:   this.getTapEntry(data).join('\n'),
            expected: '',
            message:  data.name,
            operator: data.cond,
        });
    }

    getThrown(n, options={}) {
        // TODO rename to just throw?
        const err = this.getError(n, options);
        if (err)
            throw err;
    }
}

// this is for stuff like `object foo = {"foo":42}`
// we don't want the explanation to be quoted!
function _explain( item, depth ) {
    if (typeof item === 'string' )
        return item;
    return explain( item, depth );
};

Report.prototype.explain = explain; // also make available via report

/**
 *  @desc Create new check method available via all Report instances
 *  @param {string} name Name of the new condition.
 *  Must not be present in Report already, and should NOT start with
 *  get..., set..., or add... (these are reserved for Report itself)
 *  @param {Object} options Configuring the check's handling of arguments
 *  @param {integer} options.args The required number of arguments
 *  @param {integer} [options.minArgs] Minimum number of argument (defaults to args)
 *  @param {integer} [options.maxArgs] Maximum number of argument (defaults to args)
 *  @param {boolean} [options.hasOptions] If true, an optional object
can be supplied as last argument. It won't interfere with description.
 *  @param {boolean} [options.fun] The last argument is a callback
 *  @param {Function} implementation - a callback that takes {args} arguments
 *  and returns a falsey value if condition passes
 *  ("nothing to see here, move along"),
 *  or evidence if it fails
 *  (e.g. typically a got/expected diff).
 */
const seen = new Set();
function addCondition (name, options, impl) {
    if (typeof name !== 'string')
        throw new Error('Condition name must be a string');
    if (name.match(/^(_|get[_A-Z]|set[_A-Z])/))
        throw new Error('Condition name must not start with get_, set_, or _');
    // TODO must do something about name clashes, but later
    // because eval in browser may (kind of legimitely) override conditions
    if (!seen.has(name) && Report.prototype[name])
        throw new Error('Method already exists in Report: '+name);
    if (typeof options !== 'object')
        throw new Error('bad options');
    if (typeof impl !== 'function')
        throw new Error('bad implementation');

    const minArgs    = options.minArgs || options.args;
    if (!Number.isInteger(minArgs) || minArgs < 0)
        throw new Error('args/minArgs must be nonnegative integer');
    const maxArgs    = options.maxArgs || options.args || Infinity;
    if (maxArgs !== Infinity && (!Number.isInteger(minArgs) || maxArgs < minArgs))
        throw new Error('maxArgs must be integer and greater than minArgs, or Infinity');
    const descrFirst    = options.descrFirst || options.fun || maxArgs > 10;
    const hasOptions    = !!options.hasOptions;
    const maxArgsReal   = maxArgs + (hasOptions ? 1 : 0);

    // TODO alert unknown options

    // TODO this code is cluttered, rewrite
    const code = function(...args) {
        const descr = descrFirst
            ? args.shift()
            : ( (args.length > maxArgs && typeof args[args.length-1] === 'string') ? args.pop() : undefined);
        if (args.length > maxArgsReal || args.length < minArgs)
            throw new Error('Condition '+name+' must have '+minArgs+'..'+maxArgsReal+' arguments '); // TODO

        const n = this.next(); // TODO call it advance() or smth.
        const evidence = impl( ...args );
        return this.setResult( n, evidence, descr, name );
    };

    seen.add(name);
    Report.prototype[name] = code;
}

/**
 *   @function check
 *   @memberOf Report
 *   @param evidence If false, the check is assumed to pass.
 *   A true value means the check failed.
 *   @param {string} [description]
 *   @returns {undefined}
 */

// these conditions could be under the condition library
// but we'll need them to verify the Report class itself.

addCondition(
    'check',
    {args:1},
    x=>x
);
addCondition(
    'pass',
    {args:0},
    ()=>0
);
addCondition(
    'fail',
    {args:0},
    ()=>'failed deliberately'
);
addCondition(
    'equal',
    {args:2},
    (a,b) => a === b ? 0 : [ log.got(explain(a)), log.exp(explain(b)) ]
);
addCondition(
    'match',
    {args:2},
    (a,rex) => (''+a).match(rex) ? 0 : [
        log.got( 'expected '+explain(''+a) ), // explain only to quote a
        log.exp( 'to match '+rex ),
    ]
);
addCondition(
    'nested',
    {fun:1,minArgs:1},
    (...args) => new Report().run(...args).done()
);

/**
 *   @exports Report
 *   @exports report
 *   @exports addCondition
 *   @exports explain
 */

// TODO rename log to something better

module.exports = { Report, addCondition, explain, log };

},{"../diff-tree.js":1,"./util.js":8}],8:[function(require,module,exports){
'use strict';

const { AnnotatedSet } = require( './util/annotated-set.js' );

/* Determine n-th caller up the stack */
/* Inspired by Perl's Carp module */
const inStack = /([^:\s()]+:\d+(?::\d+)?)\W*(\n|$)/g;

/**
 *  @public
 *  @function
 *  @desc Returns source position n frames up the stack
 *  @example
 *  "/foo/bar.js:25:11"
 *  @param {integer} depth How many frames to skip
 *  @returns {string} source file, line, and column, separated by colon.
 */
function callerInfo(n) {
    /* a terrible rex that basically searches for file.js:nnn:nnn several times*/
    return (new Error().stack.match(inStack)[n+1].replace(/\n$/, '') || '')
}

/**
 *  @public
 *  @function
 *  @desc Stringiry objects recursively with limited depth
 *  and circular reference tracking.
 *  Generally JSON.stringify is used as reference:
 *  strings are escaped and double-quoted; numbers, boolean, and nulls are
 *  stringified "as is"; objects and arrays are descended into.
 *  The differences follow:
 *  undefined is reported as '<undef>'.
 *  Objects that have constructors are prefixed with class names.
 *  Object and array content is abbreviated as "..." and "Circular"
 *  in case of depth exhaustion and circular reference, respectively.
 *  Functions are naively stringified.
 *  @param {Any} target Object to serialize.
 *  @param {integer} depth=3 Depth limit.
 *  @returns {string}
 */
function explain( item, depth=3, options={}, path='$', seen=new AnnotatedSet() ) {
    // simple types
    if (typeof item === 'string')
        return JSON.stringify(item); // don't want to spend time qouting
    if (typeof item === 'number' || typeof item === 'boolean' || item === null)
        return ''+item;
    if (item === undefined) return '<undef>';
    if (typeof item !== 'object') // maybe function
        return ''+item; // TODO don't print out a long function's body

    // recurse
    const whereSeen = seen.has(item);
    if (whereSeen) {
        const note = 'Circular='+whereSeen;
        return Array.isArray(item)?'[ '+note+' ]':'{ '+note+' }';
    };
    seen = seen.add( item, path ); // clones seen

    if (Array.isArray(item)) {
        if (depth < 1)
            return '[...]';
        seen.add(item);
        // TODO <x empty items>
        const list = item.map(
            (val, index) => explain(val, depth-1, options, path+'['+index+']', seen)
        );
        return '['+list.join(', ')+']'; // TODO configurable whitespace
    }

    const type = item.constructor && item.constructor.name;
    const prefix = type && type !== 'Object' ? type + ' ' : '';
    if (depth < 1)
        return prefix + '{...}';
    const list = Object.keys(item).sort().map( key => {
        const index = JSON.stringify(key);
        return index+":"+explain(item[key], depth-1, options, path+'['+index+']', seen);
    });
    return prefix + '{' + list.join(", ") + '}';

    // dunno what it is, maybe a function
    return ''+item;
}

// Must work even without assert
const hasAssert = typeof assert === 'function'
    && typeof assert.AssertionError === 'function';

const makeError = hasAssert
    ? entry => new assert.AssertionError(entry)
    : entry => new Error( entry.actual );

/**
 *   @exports callerInfo
 *   @exports explain
 */

module.exports = { callerInfo, explain, makeError };

},{"./util/annotated-set.js":9}],9:[function(require,module,exports){
'use strict';

// See also noted-set.js

class AnnotatedSet {
    constructor(all=new Set(), notes=[]) {
        this.all   = all;
        this.notes = notes;
    }
    add( item, note ) {
        if (this.all.has(item))
            return this;
        return new AnnotatedSet(
            new Set(this.all).add(item),
            [ ...this.notes, [ item, note ] ]
        );
    }
    has( item ) {
        if (!this.all.has( item ))
            return;
        for (let pair of this.notes) {
            if (pair[0] === item)
                return pair[1];
        };
        throw new Error('wtf, unreachable');
    };
};

module.exports = { AnnotatedSet };

},{}]},{},[2])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL25wbS1wYWNrYWdlcy9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImxpYi9kaWZmLXRyZWUuanMiLCJsaWIvcmVmdXRlLmpzIiwibGliL3JlZnV0ZS9jb25kL2FycmF5LmpzIiwibGliL3JlZnV0ZS9jb25kL2Jhc2ljLmpzIiwibGliL3JlZnV0ZS9jb25kL2RlZXAuanMiLCJsaWIvcmVmdXRlL2RiYy5qcyIsImxpYi9yZWZ1dGUvcmVwb3J0LmpzIiwibGliL3JlZnV0ZS91dGlsLmpzIiwibGliL3JlZnV0ZS91dGlsL2Fubm90YXRlZC1zZXQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsIid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETyB0aGlzIGhhcyBub3RoaW5nIHRvIGRvIHdpdGggcmVmdXRlIGFuZCBzaG91bGQgYmUgYSBzZXBhcmF0ZSBwYWNrYWdlXG5cbi8qXG4gKiAgVGhlc2UgY2xhc3NlcyBkZXNjcmliZSBhIHRyZWUtbGlrZSBzdHJ1Y3R1cmUgY29uc2lzdGluZyBvZiAoaW5kZW50ZWQpXG4gKiAgc3RyaW5ncyByZXByZXNlbnRpbmcgYWN0dWFsIGFuZCBleHBlY3RlZCB2YWx1ZXMgYW5kIHRoZWlyIGNvbnRleHQuXG4gKiAgQSBjcm9zcyBiZXR3ZWVuIFRBUCBhbmQgZGlmZigxKSBvdXRwdXQuXG4gKi9cblxuLypcbiAqICBCYXNlIGNsYXNzIGZvciBEaWZmQ29udGVudCAmIERpZmZUcmVlXG4gKi9cbmNsYXNzIFJlbmRlcmFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge30gLy8gcGFzc1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW5kZXIoKSB1bmltcGxlbWVudGVkIGluIHN1YmNsYXNzJyk7XG4gICAgICAgIC8vIHJldHVybiAnYSBzdHJpbmcnO1xuICAgIH1cbn1cblxuLyoqXG4gKiAgIERpZmZUcmVlIGlzIGEgY2xhc3MgdGhhdCByZXByZXNlbnRzIGEgbmVzdGVkIGluZGVudGVkXG4gKiAgIGNvbGxlY3Rpb24gb2YgYWN0dWFsL2V4cGVjdGVkIGxpbmVzLlxuICovXG5cbmNsYXNzIERpZmZUcmVlIGV4dGVuZHMgUmVuZGVyYWJsZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX2xvZyA9IFtdO1xuICAgIH1cbiAgICBhcHBlbmQgKG1zZykge1xuICAgICAgICBpZiAoIShtc2cgaW5zdGFuY2VvZiBSZW5kZXJhYmxlKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGlmZlRyZWUgZW50cnkgbXVzdCBiZSBhIFJlbmRlcmFibGUnKTtcbiAgICAgICAgdGhpcy5fbG9nLnB1c2gobXNnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbmRlcihmb3JtYXQsIGluZGVudD0wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2cubWFwKCB4PT54LnJlbmRlcihmb3JtYXQsIGluZGVudCsxKSApLmpvaW4oJycpO1xuICAgIH07XG59XG5cbi8qXG4gKiAgQW5vdGhlciBhYnN0cmFjdCBjbGFzcyAtIGFuIGFjdHVhbCBsaW5lIG9mIGRpZmYgaW5mb3JtYXRpb24uXG4gKiAgUmVxdWlyZXMgcHJlZGVmaW5lZCBtZXRhaW5mb3JtYXRpb24gdG8gZnVuY3Rpb24gY29ycmVjdGx5LlxuICovXG5cbmNsYXNzIERpZmZMaW5lIGV4dGVuZHMgUmVuZGVyYWJsZSB7XG4gICAgY29uc3RydWN0b3IoIHRleHQsIG1ldGEgKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLl9tZXRhID0gbWV0YTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhLnByZWZpeCArIHRoaXMuX3RleHQ7XG4gICAgfVxuICAgIHJlbmRlcihmb3JtYXQ9e30sIGluZGVudD0xKSB7XG4gICAgICAgIC8vIFRPRE8gYWN0dWFsbHkgdXRpbGl6ZSBmb3JtYXRcbiAgICAgICAgcmV0dXJuICcgICAgJy5yZXBlYXQoaW5kZW50LTEpK3RoaXMuX21ldGEucHJlZml4ICsgdGhpcy5fdGV4dCArICdcXG4nO1xuICAgIH1cbn1cblxuY29uc3QgRElGRl9DT05URU5UX1RZUEVTID0ge1xuICAgIGFjdHVhbDoge1xuICAgICAgICBsZXZlbDogMyxcbiAgICAgICAgcHJlZml4OiAnLSAnLFxuICAgICAgICBjb2xvcjogJ3JlZCcsXG4gICAgfSxcbiAgICBleHBlY3RlZDoge1xuICAgICAgICBsZXZlbDogMyxcbiAgICAgICAgcHJlZml4OiAnKyAnLFxuICAgICAgICBjb2xvcjogJ2dyZWVuJyxcbiAgICB9LFxuICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIGxldmVsOiAzLFxuICAgICAgICBwcmVmaXg6ICdhdCAnLCAvLyBUT0RPIEBcbiAgICAgICAgY29sb3I6ICdncmF5JyxcbiAgICB9LFxuICAgIGNvbnRleHQ6IHtcbiAgICAgICAgbGV2ZWw6IDMsXG4gICAgICAgIHByZWZpeDogJyAgJyxcbiAgICAgICAgY29sb3I6ICdncmF5JyxcbiAgICB9LFxuICAgIG5vdGU6IHtcbiAgICAgICAgbGV2ZWw6IDcsXG4gICAgICAgIHByZWZpeDogJycsXG4gICAgICAgIGNvbG9yOiAnZ3JheScsXG4gICAgfSxcbn07XG5mb3IoIGxldCBuYW1lIGluIERJRkZfQ09OVEVOVF9UWVBFUyApXG4gICAgRElGRl9DT05URU5UX1RZUEVTW25hbWVdLm5hbWU9bmFtZTtcblxuY2xhc3MgRGlmZkNvbnRlbnQgZXh0ZW5kcyBEaWZmTGluZSB7XG4gICAgY29uc3RydWN0b3IoIHRleHQsIHR5cGUgKSB7XG4gICAgICAgIGlmICghRElGRl9DT05URU5UX1RZUEVTW3R5cGVdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIERpZmZDb250ZW50IHR5cGU6ICcrdHlwZSk7XG5cbiAgICAgICAgc3VwZXIoIHRleHQsIERJRkZfQ09OVEVOVF9UWVBFU1t0eXBlXSApO1xuICAgIH1cbn1cblxuY29uc3QgRElGRl9DSEVDS19UWVBFUyA9IHtcbiAgICBwYXNzOiB7XG4gICAgICAgIGxldmVsOiAyLFxuICAgICAgICBwcmVmaXg6ICdvayAnLFxuICAgICAgICBjb2xvcjogJ2dyZWVuJyxcbiAgICB9LFxuICAgIGZhaWw6IHtcbiAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgIHByZWZpeDogJyFmYWlsICcsXG4gICAgICAgIGNvbG9yOiAncmVkJyxcbiAgICB9LFxuICAgIHBsYW46IHtcbiAgICAgICAgbGV2ZWw6IDEsXG4gICAgICAgIHByZWZpeDogJ3BsYW4gJywgLy8gVE9ETyBiZXR0ZXJcbiAgICAgICAgY29sb3I6ICdncmVlbicsXG4gICAgfSxcbn07XG5mb3IoIGxldCBuYW1lIGluIERJRkZfQ0hFQ0tfVFlQRVMgKVxuICAgIERJRkZfQ0hFQ0tfVFlQRVNbbmFtZV0ubmFtZT1uYW1lO1xuXG4vLyBUT0RPIGJldHRlciBuYW1lISFcbi8vIFRPRE8gdGhpcyBpcyBhIGNvcHlwYXN0ZSBvZiBEaWZmQ29udGVudCwgdW5pZnkgYmV0dGVyXG5jbGFzcyBEaWZmQ2hlY2sgZXh0ZW5kcyBEaWZmTGluZSB7XG4gICAgY29uc3RydWN0b3IoIHRleHQsIHR5cGUgKSB7XG4gICAgICAgIGlmICghRElGRl9DSEVDS19UWVBFU1t0eXBlXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBEaWZmQ29udGVudCB0eXBlOiAnK3R5cGUpO1xuXG4gICAgICAgIHN1cGVyKCB0ZXh0LCBESUZGX0NIRUNLX1RZUEVTW3R5cGVdICk7XG4gICAgfVxufVxuXG5jb25zdCBvdXQgPSB7IFJlbmRlcmFibGUsIERpZmZUcmVlLCBEaWZmTGluZSwgRGlmZkNvbnRlbnQgfTtcblxuT2JqZWN0LmtleXMoIERJRkZfQ09OVEVOVF9UWVBFUyApLmZvckVhY2goIGkgPT4gb3V0W2ldID0gbXNnID0+IG5ldyBEaWZmQ29udGVudCAobXNnLCBpKSk7XG5PYmplY3Qua2V5cyggRElGRl9DSEVDS19UWVBFUyApLmZvckVhY2goIGkgPT4gb3V0W2ldID0gbXNnID0+IG5ldyBEaWZmQ2hlY2sgKG1zZywgaSkpO1xuXG5vdXQubG9nID0gKCkgPT4gbmV3IERpZmZUcmVlKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gb3V0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB0aGUgY29yZSAoc2hvdWxkIGV4cGxhaW4gZXZlbiBiZSB0aGVyZT8pXG5jb25zdCB7IFJlcG9ydCwgYWRkQ29uZGl0aW9uLCBleHBsYWluIH0gPSByZXF1aXJlICgnLi9yZWZ1dGUvcmVwb3J0LmpzJyk7XG5cbi8vIGVpZmZlbC1zdHlsZSBkZXNpZ24tYnktY29udHJhY3RcbmNvbnN0IHsgREJDIH0gPSByZXF1aXJlKCAnLi9yZWZ1dGUvZGJjLmpzJyApO1xuXG4vLyBpbXBvcnQgZGVmYXVsdCBjb25kaXRpb24gYXJzZW5hbFxucmVxdWlyZSggJy4vcmVmdXRlL2NvbmQvYmFzaWMuanMnICk7XG5yZXF1aXJlKCAnLi9yZWZ1dGUvY29uZC9hcnJheS5qcycgKTtcbnJlcXVpcmUoICcuL3JlZnV0ZS9jb25kL2RlZXAuanMnICk7XG5cbmNvbnN0IGdldFJlcG9ydCA9ICguLi5hcmdzKSA9PiBuZXcgUmVwb3J0KCkucnVuKC4uLmFyZ3MpLmRvbmUoKTtcblxuLy8gQWxsb3cgY3JlYXRpbmcgbXVsdGlwbGUgcGFyYWxsZWwgY29uZmlndXJhdGlvbnMgb2YgcmVmdXRlXG4vLyBlLmcuIG9uZSBzdHJpY3QgKHRocm93aW5nIGVycm9ycykgYW5kIG90aGVyIGxheCAoanVzdCBkZWJ1Z2dpbmcgdG8gY29uc29sZSlcbmZ1bmN0aW9uIHNldHVwKCBvcHRpb25zPXt9LCBvcmlnICkge1xuICAgIC8vIFRPRE8gdmFsaWRhdGUgb3B0aW9uc1xuICAgIGNvbnN0IG9uRmFpbCA9IG9wdGlvbnMub25GYWlsIHx8IChyZXAgPT4geyB0aHJvdyBuZXcgRXJyb3IocmVwLmdldFRhcCgpKSB9KTtcblxuICAgIGNvbnN0IHJlZnV0ZSA9IG9wdGlvbnMuc2tpcFxuICAgICAgICA/ICgpPT57fVxuICAgICAgICA6ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvayA9IG5ldyBSZXBvcnQoKTtcbiAgICAgICAgICAgIG9rLm9uRG9uZSggeCA9PiB7IGlmKCAheC5nZXRQYXNzKCkgKSBvbkZhaWwoeCwgYXJncykgfSApO1xuICAgICAgICAgICAgb2sucnVuKC4uLmFyZ3MpO1xuICAgICAgICAgICAgb2suZG9uZSgpO1xuICAgICAgICB9O1xuXG4gICAgLy8gcmVleHBvcnQgYWxsIGZyb20gcmVwb3J0LmpzXG4gICAgcmVmdXRlLlJlcG9ydCA9IFJlcG9ydDtcbiAgICByZWZ1dGUuZXhwbGFpbiA9IGV4cGxhaW47XG4gICAgcmVmdXRlLmFkZENvbmRpdGlvbiA9IGFkZENvbmRpdGlvbjtcblxuICAgIC8vIHNob3J0Y3V0IHRvIHZhbGlkYXRpbmcgJiByZXR1cm5pbmcgYSBmcmVzaCBjb250cmFjdFxuICAgIC8vIFRPRE8gcmVuYW1lIHRvIGF2b2lkIG5hbWUgY2xhc2ggd2l0aCB0aGUgY2xhc3NcbiAgICAvLyAoZXZhbD8pXG4gICAgcmVmdXRlLnJlcG9ydCA9IGdldFJlcG9ydDtcblxuICAgIC8vIHJlZnV0ZS5jb25mKHsuLi59KSB3aWxsIGdlbmVyYXRlIGEgX25ld18gcmVmdXRlXG4gICAgcmVmdXRlLmNvbmZpZyA9IHVwZGF0ZSA9PiBzZXR1cCggeyAuLi5vcHRpb25zLCAuLi51cGRhdGUgfSwgcmVmdXRlICk7XG5cbiAgICAvLyBhZGQgZGVzaWduLWJ5LWNvbnRyYWN0XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCByZWZ1dGUsICdkYmMnLCB7IGdldDogKCk9Pm5ldyBEQkMoKSB9ICk7XG5cbiAgICAvLyBUT0RPIHRoaXMgaXMgc3R1cGlkLCBjb21lIHVwIHdpdGggc210aCBiZXR0ZXJcbiAgICAvLyB3aGVuIGluIGJyb3dzZXIsIHdpbmRvdy5yZWZ1dGUuY29uZmlnKCkgdXBkYXRlcyB3aW5kb3cucmVmdXRlIGl0c2VsZlxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBvcmlnID09PSB3aW5kb3cucmVmdXRlKVxuICAgICAgICB3aW5kb3cucmVmdXRlID0gcmVmdXRlO1xuXG4gICAgcmV0dXJuIHJlZnV0ZTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKVxuICAgIG1vZHVsZS5leHBvcnRzID0gc2V0dXAoKTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJylcbiAgICB3aW5kb3cucmVmdXRlID0gc2V0dXAoKTsgLy8gVE9ETyBjaGVjayBwcmVleGlzdGluZ1xuXG4vKipcbiAqICAgQGNhbGxiYWNrIENvbnRyYWN0XG4gKiAgIEBkZXNjIEEgY29kZSBibG9jayBjb250YWluaW5nIG9uZSBvciBtb3JlIGNvbmRpdGlvbiBjaGVja3MuXG4gKiAgIEEgY2hlY2sgaXMgcGVyZm9ybWVkIGJ5IGNhbGxpbmcgb25lIG9mIGEgZmV3IHNwZWNpYWwgbWV0aG9kc1xuICogICAoZXF1YWwsIG1hdGNoLCBkZWVwRXF1YWwsIHR5cGUgZXRjKVxuICogICBvbiB0aGUgUmVwb3J0IG9iamVjdC5cbiAqICAgQ29udHJhY3RzIG1heSBiZSBuZXN0ZWQgdXNpbmcgdGhlICduZXN0ZWQnIG1ldGhvZCB3aGljaCBhY2NlcHRzXG4gKiAgIGFub3RoZXIgY29udHJhY3QgYW5kIHJlY29yZHMgYSBwYXNzL2ZhaWx1cmUgaW4gdGhlIHBhcmVudCBhY2NvcmRpbmdseS5xXG4gKiAgIEEgY29udHJhY3QgaXMgYWx3YXlzIGV4ZWN1dGVkIHRvIHRoZSBlbmQuXG4gKiAgIEBwYXJhbSB7UmVwb3J0fSBvayBBbiBvYmplY3QgdGhhdCByZWNvcmRzIGNoZWNrIHJlc3VsdHMuXG4gKiAgIEBwYXJhbSB7QW55fSBbLi4ubGlzdF0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzXG4gKiAgIChlLmcuIGRhdGEgc3RydWN0dXJlIHRvIGJlIHZhbGlkYXRlZClcbiAqICAgQHJldHVybnMge3ZvaWR9IFJldHVybmVkIHZhbHVlIGlzIGlnbm9yZWQuXG4gKi9cblxuLyoqXG4gKiAgIEBwdWJsaWNcbiAqICAgQGZ1bmN0aW9uIHJlZnV0ZVxuICogICBAcGFyYW0ge0FueX0gWy4uLmxpc3RdIERhdGEgdG8gZmVlZCB0byB0aGUgY2FsbGJhY2tcbiAqICAgQHBhcmFtIHtDb250cmFjdH0gY29udHJhY3QgQSBjb2RlIGJsb2NrIHdpdGggY2hlY2tzLlxuICogICBAcmV0dXJucyB7dW5kZWZpbmVkfSBSZXR1cm4gdmFsdWUgaXMgaWdub3JlZC5cbiAqICAgQHRocm93cyB7RXJyb3J9IElmIG9uZSBvciBtb3JlIGNoZWNrcyBhcmUgZmFpbGluZywgYW4gZXhjZXB0aW9uIGlzIHRocm93blxuICogICB3aXRoIGRldGFpbHMgYWJvdXQgYWxsIHBhc3NpbmcvZmFpbGluZyBjaGVja3MuXG4gKiAgIFRoaXMgYWN0aW9uIGNhbiBiZSBjaGFuZ2VkIHZpYSByZWZ1dGUuY29uZmlnKCkgY2FsbC5cbiAqXG4gKi9cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGFkZENvbmRpdGlvbiwgUmVwb3J0IH0gPSByZXF1aXJlKCAnLi4vcmVwb3J0LmpzJyApO1xuXG4vLyBUT0RPIHJlbmFtZSBmb3JFYWNoIG9yIHNtdGguXG5hZGRDb25kaXRpb24oXG4gICAgJ21hcCcsXG4gICAge2Z1bjoxLGFyZ3M6Mn0sXG4gICAgKGxpc3QsIGNvbnRyYWN0KSA9PiB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgYSBsaXN0LCBmb3VuZCBhICcudHlwZW9mKGxpc3QpO1xuICAgICAgICBpZiAobGlzdC5sZW5ndGggPCAxKVxuICAgICAgICAgICAgcmV0dXJuIDA7IC8vIGF1dG8tcGFzc1xuXG4gICAgICAgIGNvbnN0IG9rID0gbmV3IFJlcG9ydCgpO1xuICAgICAgICBsaXN0LmZvckVhY2goIChpdGVtLCBpbmRleCkgPT4gb2submVzdGVkKCBcIml0ZW0gXCIraW5kZXgsIGl0ZW0sIGNvbnRyYWN0ICkgKTtcbiAgICAgICAgcmV0dXJuIG9rLmRvbmUoKTtcbiAgICB9XG4pO1xuXG4vLyBUT0RPIHRoaXMgaXMgY2FsbGVkIFwiY29tcGxpYW50IGNoYWluXCIgYnV0IGJldHRlciBqdXN0IHNheSBoZXJlXG4vLyBcIm9oIHdlJ3JlIGNoZWNraW5nIGVsZW1lbnQgb3JkZXJcIlxuYWRkQ29uZGl0aW9uKFxuICAgICdvcmRlcmVkJywgLy8gVE9ETyBiZXR0ZXIgbmFtZT9cbiAgICB7ZnVuOjEsYXJnczoyfSxcbiAgICAobGlzdCwgY29udHJhY3QpID0+IHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKVxuICAgICAgICAgICAgcmV0dXJuICdFeHBlY3RlZCBhIGxpc3QsIGZvdW5kIGEgJy50eXBlb2YobGlzdCk7XG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA8IDIpXG4gICAgICAgICAgICByZXR1cm4gMDsgLy8gYXV0by1wYXNzXG5cbiAgICAgICAgY29uc3Qgb2sgPSBuZXcgUmVwb3J0KCk7XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgbGlzdC5sZW5ndGgtMTsgbisrKSB7XG4gICAgICAgICAgICBvay5uZXN0ZWQoIFwiaXRlbXMgXCIrbitcIiwgXCIrKG4rMSksIGxpc3Rbbl0sIGxpc3RbbisxXSwgY29udHJhY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvay5kb25lKCk7XG4gICAgfVxuKTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IGFkZENvbmRpdGlvbiwgcmVwb3J0LCBleHBsYWluLCBsb2cgfSA9IHJlcXVpcmUoICcuLi9yZXBvcnQuanMnICk7XG5jb25zdCBPSyA9IGZhbHNlO1xuXG5jb25zdCBudW1DbXAgPSB7XG4gICAgJzwnIDogKHgseSk9Pih4ICA8IHkpLFxuICAgICc+JyA6ICh4LHkpPT4oeCAgPiB5KSxcbiAgICAnPD0nOiAoeCx5KT0+KHggPD0geSksXG4gICAgJz49JzogKHgseSk9Pih4ID49IHkpLFxuICAgICc9PSc6ICh4LHkpPT4oeCA9PT0geSksXG4gICAgJyE9JzogKHgseSk9Pih4ICE9PSB5KSxcbn07XG5cbi8vIHVzZSAhPSBhbmQgbm90ICE9PSBkZWxpYmVyYXRlbHkgdG8gZmlsdGVyIG91dCBudWxsICYgdW5kZWZpbmVkXG5jb25zdCBzdHJDbXAgPSB7XG4gICAgJzwnIDogKHgseSk9PnggIT0gdW5kZWZpbmVkICYmIHkgIT0gdW5kZWZpbmVkICYmICgnJyt4ICA8ICcnK3kpLFxuICAgICc+JyA6ICh4LHkpPT54ICE9IHVuZGVmaW5lZCAmJiB5ICE9IHVuZGVmaW5lZCAmJiAoJycreCAgPiAnJyt5KSxcbiAgICAnPD0nOiAoeCx5KT0+eCAhPSB1bmRlZmluZWQgJiYgeSAhPSB1bmRlZmluZWQgJiYgKCcnK3ggPD0gJycreSksXG4gICAgJz49JzogKHgseSk9PnggIT0gdW5kZWZpbmVkICYmIHkgIT0gdW5kZWZpbmVkICYmICgnJyt4ID49ICcnK3kpLFxuXG4gICAgJz09JzogKHgseSk9PnggIT0gdW5kZWZpbmVkICYmIHkgIT0gdW5kZWZpbmVkICYmICgnJyt4ID09PSAnJyt5KSxcbiAgICAnIT0nOiAoeCx5KT0+KCh4ID09IHVuZGVmaW5lZCleKHkgPT0gdW5kZWZpbmVkKSkgfHwgKCcnK3ggIT09ICcnK3kpLFxufTtcblxuYWRkQ29uZGl0aW9uKFxuICAgICdudW1DbXAnLFxuICAgIHthcmdzOjN9LFxuICAgICh4LG9wLHkpID0+IG51bUNtcFtvcF0oeCx5KT8wOltleHBsYWluKHgpLFwiaXMgbm90IFwiK29wLGV4cGxhaW4oeSldXG4pO1xuYWRkQ29uZGl0aW9uKFxuICAgICdzdHJDbXAnLFxuICAgIHthcmdzOjN9LFxuICAgICh4LG9wLHkpID0+IHN0ckNtcFtvcF0oeCx5KT8wOltleHBsYWluKHgpLFwiaXMgbm90IFwiK29wLGV4cGxhaW4oeSldXG4pO1xuXG5jb25zdCB0eXBlQ2hlY2sgPSB7XG4gICAgdW5kZWZpbmVkOiB4ID0+IHggPT09IHVuZGVmaW5lZCxcbiAgICBudWxsOiAgICAgIHggPT4geCA9PT0gbnVsbCxcbiAgICBudW1iZXI6ICAgIHggPT4gdHlwZW9mIHggPT09ICdudW1iZXInICYmICFOdW1iZXIuaXNOYU4oeCksXG4gICAgaW50ZWdlcjogICB4ID0+IE51bWJlci5pc0ludGVnZXIoeCksXG4gICAgbmFuOiAgICAgICB4ID0+IE51bWJlci5pc05hTih4KSxcbiAgICBzdHJpbmc6ICAgIHggPT4gdHlwZW9mIHggPT09ICdzdHJpbmcnLFxuICAgIGZ1bmN0aW9uOiAgeCA9PiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAgIHggPT4gdHlwZW9mIHggPT09ICdib29sZWFuJyxcbiAgICBvYmplY3Q6ICAgIHggPT4geCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoeCksXG4gICAgYXJyYXk6ICAgICB4ID0+IEFycmF5LmlzQXJyYXkoeCksXG59O1xuZnVuY3Rpb24gdHlwZUV4cGxhaW4gKHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4geDtcbiAgICBpZiAodHlwZW9mIHggPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJldHVybiAnaW5zdGFuY2VvZiAnKyh4Lm5hbWUgfHwgeCk7XG59O1xuXG5hZGRDb25kaXRpb24oXG4gICAgJ3R5cGUnLFxuICAgIHthcmdzOiAyfSxcbiAgICAoZ290LCBleHApPT57XG4gICAgICAgIGlmICggIUFycmF5LmlzQXJyYXkoZXhwKSApXG4gICAgICAgICAgICBleHAgPSBbZXhwXTtcblxuICAgICAgICBmb3IgKGxldCB2YXJpYW50IG9mIGV4cCkge1xuICAgICAgICAgICAgLy8ga25vd24gdHlwZVxuICAgICAgICAgICAgaWYoIHR5cGVvZiB2YXJpYW50ID09PSAnc3RyaW5nJyAmJiB0eXBlQ2hlY2tbdmFyaWFudF0gKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVDaGVja1t2YXJpYW50XShnb3QpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT0s7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBpbnN0YW5jZW9mXG4gICAgICAgICAgICBpZiggdHlwZW9mIHZhcmlhbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGdvdCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiggZ290IGluc3RhbmNlb2YgdmFyaWFudCApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPSztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGRvbid0IGtub3cgd2hhdCB5b3UncmUgYXNraW5nIGZvclxuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duIHZhbHVlIHR5cGUgc3BlYzogJytleHBsYWluKHZhcmlhbnQsIDEpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbG9nLmdvdChleHBsYWluKGdvdCwgMSkpLFxuICAgICAgICAgICAgbG9nLmV4cChleHAubWFwKCB0eXBlRXhwbGFpbiApLmpvaW4oXCIgb3IgXCIpKSxcbiAgICAgICAgXTtcbiAgICB9XG4pO1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgYWRkQ29uZGl0aW9uLCBleHBsYWluLCBsb2cgfSA9IHJlcXVpcmUoICcuLi9yZXBvcnQuanMnICk7XG5jb25zdCB7IEFubm90YXRlZFNldCB9ID0gcmVxdWlyZSggJy4uL3V0aWwvYW5ub3RhdGVkLXNldC5qcycgKTtcblxuYWRkQ29uZGl0aW9uKCAnZGVlcEVxdWFsJywge1wiYXJnc1wiOjIsaGFzT3B0aW9uczp0cnVlfSwgZGVlcCApO1xuXG5mdW5jdGlvbiBkZWVwKCBnb3QsIGV4cCwgb3B0aW9ucz17fSApIHtcbiAgICBpZiAoIW9wdGlvbnMubWF4KVxuICAgICAgICBvcHRpb25zLm1heCA9IDU7XG4gICAgb3B0aW9ucy5kaWZmID0gW107XG4gICAgX2RlZXAoIGdvdCwgZXhwLCBvcHRpb25zICk7XG4gICAgaWYgKCFvcHRpb25zLmRpZmYubGVuZ3RoKVxuICAgICAgICByZXR1cm4gMDtcblxuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGl0ZW0gb2Ygb3B0aW9ucy5kaWZmKSB7XG4gICAgICAgIHJldC5wdXNoKCBcbiAgICAgICAgICAgIGxvZy5sb2MoaXRlbVswXSksXG4gICAgICAgICAgICBsb2cuZ290KGl0ZW1bM10gPyBpdGVtWzFdIDogZXhwbGFpbiggaXRlbVsxXSwgMiApKSxcbiAgICAgICAgICAgIGxvZy5leHAoaXRlbVszXSA/IGl0ZW1bMl0gOiBleHBsYWluKCBpdGVtWzJdLCAyICkpLFxuICAgICAgICApO1xuICAgIH07XG4gICAgcmV0dXJuIHJldDtcbn07XG5cbi8vIHJlc3VsdCBpcyBzdG9yZWQgaW4gb3B0aW9ucy5kaWZmPVtdLCByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuLy8gaWYgc2FpZCBkaWZmIGV4Y2VlZHMgbWF4LCByZXR1cm4gaW1tZWRpYXRlbHkgJiBkb24ndCB3YXN0ZSB0aW1lXG5mdW5jdGlvbiBfZGVlcCggZ290LCBleHAsIG9wdGlvbnM9e30sIHBhdGg9JyQnLCBzZWVuTD1uZXcgQW5ub3RhdGVkU2V0KCksIHNlZW5SPW5ldyBBbm5vdGF0ZWRTZXQoKSApIHtcbiAgICBpZiAoZ290ID09PSBleHAgfHwgb3B0aW9ucy5tYXggPD0gb3B0aW9ucy5kaWZmLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgZ290ICE9PSB0eXBlb2YgZXhwKVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5kaWZmLnB1c2goIFtwYXRoLCBnb3QsIGV4cCBdICk7XG5cbiAgICAvLyByZWN1cnNlIGJ5IGV4cGVjdGVkIHZhbHVlIC0gY29uc2lkZXIgaXQgbW9yZSBwcmVkaWN0YWJsZVxuICAgIGlmICh0eXBlb2YgZXhwICE9PSAnb2JqZWN0JyB8fCBleHAgPT09IG51bGwgKSB7XG4gICAgICAgIC8vIG5vbi1vYmplY3RzIC0gc28gY2FuJ3QgZGVzY2VuZFxuICAgICAgICAvLyBhbmQgY29tcGFyaXNvbiBhbHJlYWR5IGRvbmUgYXQgdGhlIGJlZ2lubm5pbmdcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGlmZi5wdXNoKCBbcGF0aCwgZ290LCBleHAgXSApO1xuICAgIH1cblxuICAgIC8vIG11c3QgZGV0ZWN0IGxvb3BzIGJlZm9yZSBnb2luZyBkb3duXG4gICAgY29uc3QgcGF0aEwgPSBzZWVuTC5oYXMoZ290KTtcbiAgICBjb25zdCBwYXRoUiA9IHNlZW5SLmhhcyhleHApO1xuICAgIGlmIChwYXRoTCB8fCBwYXRoUikge1xuICAgICAgICAvLyBMb29wIGRldGVjdGVkID0gb25seSBjaGVjayB0b3BvbG9neVxuICAgICAgICBpZiAocGF0aEwgPT09IHBhdGhSKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICByZXR1cm4gb3B0aW9ucy5kaWZmLnB1c2goIFtcbiAgICAgICAgICAgIHBhdGggKyAnIChjaXJjdWxhciknLFxuICAgICAgICAgICAgcGF0aEwgPyAnQ2lyY3VsYXI9JytwYXRoTCA6IGV4cGxhaW4oZ290LCAyKSxcbiAgICAgICAgICAgIHBhdGhSID8gJ0NpcmN1bGFyPScrcGF0aFIgOiBleHBsYWluKGV4cCwgMiksXG4gICAgICAgICAgICB0cnVlIC8vIGRvbid0IHN0cmluZ2lmeVxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIHNlZW5MID0gc2VlbkwuYWRkKGdvdCwgcGF0aCk7XG4gICAgc2VlblIgPSBzZWVuUi5hZGQoZXhwLCBwYXRoKTtcblxuICAgIC8vIGNvbXBhcmUgb2JqZWN0IHR5cGVzXG4gICAgLy8gKGlmIGEgdXNlciBpcyBzdHVwaWQgZW5vdWdoIHRvIG92ZXJyaWRlIGNvbnN0cnVjdG9yIGZpZWxkLCB3ZWxsIHRoZSB0ZXN0XG4gICAgLy8gd291bGQgZmFpbCBsYXRlciBhbnl3YXkpXG4gICAgaWYgKGdvdC5jb25zdHJ1Y3RvciAhPT0gZXhwLmNvbnN0cnVjdG9yKVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5kaWZmLnB1c2goIFtwYXRoLCBnb3QsIGV4cCBdICk7XG5cbiAgICAvLyBhcnJheVxuICAgIGlmIChBcnJheS5pc0FycmF5KGV4cCkpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGdvdCkgfHwgZ290Lmxlbmd0aCAhPT0gZXhwLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRpZmYucHVzaCggW3BhdGgsIGdvdCwgZXhwIF0gKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2RlZXAoIGdvdFtpXSwgZXhwW2ldLCBvcHRpb25zLCBwYXRoKydbJytpKyddJywgc2VlbkwsIHNlZW5SICk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5tYXg8PW9wdGlvbnMuZGlmZi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgLy8gY29tcGFyZSBrZXlzIC0gKzEgZm9yIGV4cCwgLTEgZm9yIGdvdCwgbm9uemVybyBrZXkgYXQgZW5kIG1lYW5zIGtleXMgZGlmZmVyXG4gICAgY29uc3QgdW5pcSA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGV4cCkuZm9yRWFjaCggeCA9PiB1bmlxW3hdID0gMSApO1xuICAgIE9iamVjdC5rZXlzKGdvdCkuZm9yRWFjaCggeCA9PiB1bmlxW3hdID0gKHVuaXFbeF0gfHwgMCkgLSAxICk7XG4gICAgZm9yIChsZXQgeCBpbiB1bmlxKSB7XG4gICAgICAgIGlmICh1bmlxW3hdICE9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZGlmZi5wdXNoKCBbcGF0aCwgZ290LCBleHAgXSApO1xuICAgIH1cbiAgICBcbiAgICAvLyBub3cgdHlwZW9mLCBvYmplY3QgdHlwZSwgYW5kIG9iamVjdCBrZXlzIGFyZSB0aGUgc2FtZS5cbiAgICAvLyByZWN1cnNlLlxuICAgIGZvciAobGV0IGkgaW4gZXhwKSB7XG4gICAgICAgIF9kZWVwKCBnb3RbaV0sIGV4cFtpXSwgb3B0aW9ucywgcGF0aCsnWycrZXhwbGFpbihpKSsnXScsIHNlZW5MLCBzZWVuUiApO1xuICAgICAgICBpZiAob3B0aW9ucy5tYXg8PW9wdGlvbnMuZGlmZi5sZW5ndGgpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9O1xuICAgIHJldHVybjtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBSZXBvcnQgfSA9IHJlcXVpcmUgKCAnLi9yZXBvcnQuanMnICk7XG5jb25zdCBub29wID0gKCk9Pnt9O1xuXG5jbGFzcyBEQkMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9wcmUgICAgPSBub29wO1xuICAgICAgICB0aGlzLl9wb3N0ICAgPSBub29wO1xuICAgICAgICB0aGlzLl9vbmZhaWwgPSByZXBvcnQgPT4gcmVwb3J0LmdldFRocm93bigpO1xuICAgICAgICB0aGlzLl9vbnBvc3QgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBvc3QoY29kZSkge1xuICAgICAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgY29kZSAhPT0gJ2Z1bmN0aW9uJyApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb3N0LWNvbmRpdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIHRoaXMuX3Bvc3QgPSBjb2RlO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJlKGNvZGUpIHtcbiAgICAgICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ByZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgY29kZSAhPT0gJ2Z1bmN0aW9uJyApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmUtY29uZGl0aW9uIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgdGhpcy5fcHJlID0gY29kZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlY29yYXRlKG9yaWcpIHtcbiAgICAgICAgLy8gY2xvc2UgYXJvdW5kIHRoZXNlIHZhcnNcbiAgICAgICAgY29uc3QgcHJlICAgID0gdGhpcy5fcHJlO1xuICAgICAgICBjb25zdCBwb3N0ICAgPSB0aGlzLl9wb3N0O1xuICAgICAgICBjb25zdCBvbmZhaWwgPSB0aGlzLl9vbmZhaWw7XG4gICAgICAgIGNvbnN0IG9ucG9zdCA9IHRoaXMuX29ucG9zdCB8fCB0aGlzLl9vbmZhaWw7XG5cbiAgICAgICAgLy8gbm8gYXJyb3cgZnVuY3Rpb24gdG8gZ2V0IGNvcnJlY3QgJ3RoaXMnIG9iamVjdFxuICAgICAgICBjb25zdCBjb2RlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHJQcmUgPSBuZXcgUmVwb3J0KCk7XG4gICAgICAgICAgICBwcmUuYXBwbHkoIHRoaXMsIFsgclByZSwgdW5kZWZpbmVkLCAuLi5hcmdzIF0gKTtcbiAgICAgICAgICAgIGlmKCFyUHJlLmdldFBhc3MoKSlcbiAgICAgICAgICAgICAgICBvbmZhaWwoclByZS5zZXRUaXRsZSgncHJlLWNvbmRpdGlvbiBmYWlsZWQnKSk7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBvcmlnLmFwcGx5KCB0aGlzLCBhcmdzICk7XG4gICAgICAgICAgICBjb25zdCByUG9zdCA9IG5ldyBSZXBvcnQoKTtcbiAgICAgICAgICAgIHBvc3QuYXBwbHkoIHRoaXMsIFsgclBvc3QsIHJldCwgLi4uYXJncyBdICk7XG4gICAgICAgICAgICBpZighclBvc3QuZ2V0UGFzcygpKVxuICAgICAgICAgICAgICAgIG9ucG9zdChyUG9zdC5zZXRUaXRsZSgncG9zdC1jb25kaXRpb24gZmFpbGVkJykpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvZGUub3JpZyA9IG9yaWc7XG4gICAgICAgIGNvZGUucHJlICA9IHByZTtcbiAgICAgICAgY29kZS5wb3N0ID0gcG9zdDtcblxuICAgICAgICByZXR1cm4gY29kZTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBEQkMgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBjYWxsZXJJbmZvLCBleHBsYWluLCBtYWtlRXJyb3IgfSA9IHJlcXVpcmUoICcuL3V0aWwuanMnICk7XG5jb25zdCBkdCA9IHJlcXVpcmUoICcuLi9kaWZmLXRyZWUuanMnICk7IC8vIFRPRE8gc2hvdWxkIGJlIGV4dGVybmFsIHBhY2thZ2VcblxuLy8gVE9ETyBiZXR0ZXIgbmFtZXMsIGFuZCBkaWZmLXRyZWUgc2hvdWxkIGV4cG9ydCB0aG9zZSBmcm9tIHRoZSBzdGFydFxuY29uc3QgbG9nID0ge1xuICAgIGdvdDogZHQuYWN0dWFsLFxuICAgIGV4cDogZHQuZXhwZWN0ZWQsXG4gICAgY3R4OiBkdC5jb250ZXh0LFxuICAgIGxvYzogZHQubG9jYXRpb24sXG4gICAgbm90ZTogZHQubm90ZSxcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICogQGNsYXNzZGVzY1xuICogVGhlIGNvcmUgb2YgdGhlIHJlZnV0ZSBsaWJyYXJ5LCB0aGUgcmVwb3J0IG9iamVjdCBjb250YWlucyBpbmZvXG4gKiBhYm91dCBwYXNzaW5nIGFuZCBmYWlsaW5nIGNvbmRpdGlvbnMuXG4gKi9cbmNsYXNzIFJlcG9ydCB7XG4gICAgLy8gc2V0dXBcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fY291bnQgICAgID0gMDtcbiAgICAgICAgdGhpcy5fZmFpbENvdW50ID0gMDtcbiAgICAgICAgdGhpcy5fZGVzY3IgICAgID0gW107XG4gICAgICAgIHRoaXMuX2V2aWRlbmNlICA9IFtdO1xuICAgICAgICB0aGlzLl93aGVyZSAgICAgPSBbXTtcbiAgICAgICAgdGhpcy5fY29uZE5hbWUgID0gW107XG4gICAgICAgIHRoaXMuX2luZm8gICAgICA9IFtdO1xuICAgICAgICB0aGlzLl9uZXN0ZWQgICAgPSBbXTtcbiAgICAgICAgdGhpcy5fcGVuZGluZyAgID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9vbkRvbmUgICAgPSBbXTtcbiAgICAgICAgdGhpcy5fZG9uZSAgICAgID0gZmFsc2U7XG4gICAgICAgIC8vIFRPRE8gYWRkIGNhbGxlciBpbmZvIGFib3V0IHRoZSByZXBvcnQgaXRzZWxmXG4gICAgfVxuXG4gICAgLy8gc2V0dXAgLSBtdXN0IGJlIGNoYWluYWJsZVxuICAgIHNldFRpdGxlKHN0cikge1xuICAgICAgICB0aGlzLl90aXRsZSA9IHN0cjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIG9uRG9uZShmbikge1xuICAgICAgICB0aGlzLl9vbkRvbmUucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICAvLyBydW5uaW5nXG4gICAgLy8gVE9ETyBlaXRoZXIgYXN5bmMoKSBzaG91bGQgc3VwcG9ydCBhZGRpdGlvbmFsIGFyZ3MsIG9yIHJ1bigpIHNob3VsZG4ndFxuICAgIHJ1biguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvY2soKTtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhcmdzLnBvcCgpO1xuICAgICAgICBpZiAodHlwZW9mIGJsb2NrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMYXN0IGFyZ3VtZW50IG9mIHJ1bigpIG11c3QgYmUgYSBmdW5jdGlvbiwgbm90ICcrdHlwZW9mKGJsb2NrKSk7XG4gICAgICAgIGJsb2NrKCB0aGlzLCAuLi5hcmdzICk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFRPRE8gZWl0aGVyIGFzeW5jKCkgc2hvdWxkIHN1cHBvcnQgYWRkaXRpb25hbCBhcmdzLCBvciBydW4oKSBzaG91bGRuJ3RcbiAgICBhc3luYyh0aW1lb3V0LCBibG9jaykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAoKSA9PiByZWplY3QobmV3IEVycm9yKFwiQ29udHJhY3QgZXhlY3V0aW9uIHRvb2sgdG9vIGxvbmdcIikpLFxuICAgICAgICAgICAgICAgIHRpbWVvdXRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICB0aGlzLm9uRG9uZShhcmcgPT4ge2NsZWFyVGltZW91dCh0aW1lcik7IHJlc29sdmUoYXJnKX0pO1xuICAgICAgICAgICAgYmxvY2sodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEluIHRoZW9yeSwgaGF2aW5nIGNvbnN0IG49bmV4dCgpOyBzZXRSZXN1bHQobi4gLi4uKVxuICAgIC8vIHNob3VsZCBhbGxvdyBmb3IgYXN5bmMgY29uZGl0aW9ucyBpbiB0aGUgZnV0dXJlXG4gICAgLy8gaWYgYXQgYWxsIHBvc3NpYmxlIHdpdGhvdXQgZ3JlYXQgc2FjcmlmaWNlcy5cbiAgICBuZXh0KCkge1xuICAgICAgICB0aGlzLl9sb2NrKCk7XG4gICAgICAgIHJldHVybiArK3RoaXMuX2NvdW50O1xuICAgIH1cblxuICAgIHNldFJlc3VsdCAobiwgZXZpZGVuY2UsIGRlc2NyLCBjb25kTmFtZSwgd2hlcmUpIHtcbiAgICAgICAgaWYoIXRoaXMuX3BlbmRpbmcuaGFzKG4pKVxuICAgICAgICAgICAgdGhpcy5fbG9jaygpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nLmRlbGV0ZShuKTtcbiAgICAgICAgaWYgKG4gPiB0aGlzLl9jb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvciAoJ0F0dGVtcHQgdG8gc2V0IGNvbmRpdGlvbiBiZXlvbmQgY2hlY2sgY291bnQnKTtcbiAgICAgICAgaWYgKGRlc2NyKVxuICAgICAgICAgICAgdGhpcy5fZGVzY3Jbbl0gPSBkZXNjcjtcbiAgICAgICAgLy8gcGFzcyAtIHJldHVybiBBU0FQXG4gICAgICAgIGlmICghZXZpZGVuY2UpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgLy8gbmVzdGVkIHJlcG9ydCBuZWVkcyBzcGVjaWFsIGhhbmRsaW5nXG4gICAgICAgIGlmIChldmlkZW5jZSBpbnN0YW5jZW9mIFJlcG9ydCkge1xuICAgICAgICAgICAgdGhpcy5fbmVzdGVkW25dID0gZXZpZGVuY2U7XG4gICAgICAgICAgICBpZiAoZXZpZGVuY2UuZ2V0RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2aWRlbmNlLmdldFBhc3MoKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBzaG9ydC1jaXJjdWl0IGlmIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgZXZpZGVuY2UgPSBbXTsgLy8gaGFjayAtIGZhaWxpbmcgd2l0aG91dCBleHBsYW5hdGlvblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBuZXN0ZWQgY29udHJhY3QgaXMgaW4gYXN5bmMgbW9kZSAtIGNvZXJjZSBpbnRvIGEgcHJvbWlzZVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJ5ID0gZXZpZGVuY2U7XG4gICAgICAgICAgICAgICAgZXZpZGVuY2UgPSBuZXcgUHJvbWlzZSggZG9uZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJ5Lm9uRG9uZSggZG9uZSApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gcGVuZGluZyAtIHdlJ3JlIGluIGFzeW5jIG1vZGVcbiAgICAgICAgaWYgKGV2aWRlbmNlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZy5hZGQobik7XG4gICAgICAgICAgICB3aGVyZSA9IHdoZXJlIHx8IGNhbGxlckluZm8oMik7IC8vIG11c3QgcmVwb3J0IGFjdHVhbCBjYWxsZXIsIG5vdCB0aGVuXG4gICAgICAgICAgICBldmlkZW5jZS50aGVuKCB4ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJlc3VsdChuLCB4LCBkZXNjciwgY29uZE5hbWUsIHdoZXJlICk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0RG9uZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNiIG9mIHRoaXMuX29uRG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29lcmNlIGV2aWRlbmNlIGludG8gYSBsaXN0IG9mIGRpZmYtdHJlZSBvYmplY3RzXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShldmlkZW5jZSkpXG4gICAgICAgICAgICBldmlkZW5jZSA9IFsgZXZpZGVuY2UgXTtcbiAgICAgICAgdGhpcy5fZXZpZGVuY2Vbbl0gPSBldmlkZW5jZS5tYXAoXG4gICAgICAgICAgICB4PT54IGluc3RhbmNlb2YgZHQuRGlmZkNvbnRlbnQgPyB4IDogbG9nLm5vdGUoIF9leHBsYWluKHgsIEluZmluaXR5KSApICk7XG4gICAgICAgIHRoaXMuX3doZXJlW25dICAgID0gd2hlcmUgfHwgY2FsbGVySW5mbygyKTtcbiAgICAgICAgdGhpcy5fY29uZE5hbWVbbl0gPSBjb25kTmFtZTtcbiAgICAgICAgdGhpcy5fZmFpbENvdW50Kys7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEFwcGVuZCBhbiBpbmZvcm1hdGlvbmFsIG1lc3NhZ2UgdG8gdGhlIHJlcG9ydC5cbiAgICAgKiBOb24tc3RyaW5nIHZhbHVlcyB3aWxsIGJlIHN0cmluZ2lmaWVkIHZpYSBleHBsYWluKCkuXG4gICAgICogQHBhcmFtIHtBbnl9IG1lc3NhZ2VcbiAgICAgKiBAcmV0dXJucyB7UmVwb3J0fSBjaGFpbmFibGVcbiAgICAgKi9cbiAgICBpbmZvKCAuLi5tZXNzYWdlICkge1xuICAgICAgICB0aGlzLl9sb2NrKCk7XG4gICAgICAgIGlmICghdGhpcy5faW5mb1t0aGlzLl9jb3VudF0pXG4gICAgICAgICAgICB0aGlzLl9pbmZvW3RoaXMuX2NvdW50XSA9IFtdO1xuICAgICAgICB0aGlzLl9pbmZvW3RoaXMuX2NvdW50XS5wdXNoKCBsb2cubm90ZSggbWVzc2FnZS5tYXAoIHM9Pl9leHBsYWluKHMpICkuam9pbihcIiBcIikgKSApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBkb25lKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2RvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nLnNpemUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjYiBvZiB0aGlzLl9vbkRvbmUpXG4gICAgICAgICAgICAgICAgICAgIGNiKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBxdWVyeWluZ1xuICAgIGdldFRpdGxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGl0bGU7IC8vSkZZSVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiAgIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGdldERvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kb25lICYmICF0aGlzLl9wZW5kaW5nLnNpemU7IC8vIGlzIGl0IGV2ZW4gbmVlZGVkP1xuICAgIH1cblxuICAgIF9sb2NrICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RvbmUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHQgdG8gbW9kaWZ5IGEgZmluaXNoZWQgY29udHJhY3QnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgIEBkZXNjIFdpdGhvdXQgYXJndW1lbnQgcmV0dXJucyB3aGV0aGVyIHRoZSBjb250cmFjdCB3YXMgZnVsZmlsbGVkLlxuICAgICAqICAgQXMgYSBzcGVjaWFsIGNhc2UsIGlmIG5vIGNoZWNrcyB3ZXJlIHJ1biBhbmQgdGhlIGNvbnRyYWN0IGlzIGZpbmlzaGVkLFxuICAgICAqICAgcmV0dXJucyBmYWxzZSwgYXMgaW4gXCJzb21lb25lIG11c3QgaGF2ZSBmb3Jnb3R0ZW4gdG8gZXhlY3V0ZVxuICAgICAqICAgcGxhbm5lZCBjaGVja3MuIFVzZSBwYXNzKCkgaWYgbm8gY2hlY2tzIGFyZSBwbGFubmVkLlxuICAgICAqXG4gICAgICogICBJZiBhIHBhcmFtZXRlciBpcyBnaXZlbiwgcmV0dXJuIHRoZSBzdGF0dXMgb2Ygbi10aCBjaGVjayBpbnN0ZWFkLlxuICAgICAqICAgQHBhcmFtIHtpbnRlZ2VyfSBuXG4gICAgICogICBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBnZXRQYXNzKG4pIHtcbiAgICAgICAgaWYgKG4gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWlsQ291bnQgPT09IDAgJiYgKCF0aGlzLmdldERvbmUoKSB8fCB0aGlzLl9jb3VudCA+IDApO1xuICAgICAgICByZXR1cm4gKG4gPiAwICYmIG4gPD0gdGhpcy5fY291bnQpID8gIXRoaXMuX2V2aWRlbmNlW25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICAgQGRlc2MgTnVtYmVyIG9mIGNoZWNrcyBwZXJmb3JtZWQuXG4gICAgICogICBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIEBkZXNjIFdoZXRoZXIgdGhlIGxhc3QgY2hlY2sgd2FzIGEgc3VjY2Vzcy5cbiAgICAgKiAgVGhpcyBpcyBqdXN0IGEgc2hvcnRjdXQgZm9yIGZvby5nZXREZXRhaWxzKGZvby5nZXRDb3VudCkucGFzc1xuICAgICAqICBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBsYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY291bnQgPyAhdGhpcy5fZXZpZGVuY2VbdGhpcy5fY291bnRdIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICAgQGRlc2MgTnVtYmVyIG9mIGNoZWNrcyBmYWlsaW5nLlxuICAgICAqICAgQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRGYWlsQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYWlsQ291bnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogICBAZGVzYyBSZXR1cm4gYSBzdHJpbmcgb2YgZmFpbGluZy9wYXNzaW5nIGNoZWNrcy5cbiAgICAgKiAgIFRoaXMgbWF5IGJlIHVzZWZ1bCBmb3IgdmFsaWRhdGluZyBjdXN0b20gY29uZGl0aW9ucy5cbiAgICAgKiAgIENvbnNlY3V0aXZlIHBhc3NpbmcgY2hlY2thIGFyZSByZXByZXNlbnRlZCBieSBudW1iZXJzLlxuICAgICAqICAgQSBjYXBpdGFsIGxldHRlciBpbiB0aGUgc3RyaW5nIHJlcHJlc2VudHMgZmFpbHVyZS5cbiAgICAgKiAgIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICogICBAZXhhbXBsZVxuICAgICAqICAgLy8gMTAgcGFzc2luZyBjaGVja3NcbiAgICAgKiAgIFwicigxMClcIlxuICAgICAqICAgQGV4YW1wbGVcbiAgICAgKiAgIC8vIDEwIGNoZWNrcyB3aXRoIDEgZmFpbHVyZSBpbiB0aGUgbWlkZGxlXG4gICAgICogICBcInIoNSxOLDQpXCJcbiAgICAgKiAgIEBleGFtcGxlXG4gICAgICogICAvLyAxMCBjaGVja3MgaW5jbHVkaW5nIGEgbmVzdGVkIGNvbnRyYWN0XG4gICAgICogICBcInIoMyxyKDEsTiksNilcIlxuICAgICAqICAgQGV4YW1wbGVcbiAgICAgKiAgIC8vIG5vIGNoZWNrcyB3ZXJlIHJ1biAtIGF1dG8tZmFpbFxuICAgICAqICAgXCJyKFopXCJcbiAgICAgKi9cbiAgICBnZXRHaG9zdCgpIHtcbiAgICAgICAgY29uc3QgZ2hvc3QgPSBbXTtcbiAgICAgICAgbGV0IHN0cmVhayA9IDA7XG4gICAgICAgIGZvciAobGV0IGk9MTsgaSA8PSB0aGlzLl9jb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZXZpZGVuY2VbaV0gfHwgdGhpcy5fbmVzdGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmVhaykgZ2hvc3QucHVzaChzdHJlYWspO1xuICAgICAgICAgICAgICAgIHN0cmVhayA9IDA7XG4gICAgICAgICAgICAgICAgZ2hvc3QucHVzaCggdGhpcy5fbmVzdGVkW2ldID8gdGhpcy5fbmVzdGVkW2ldLmdldEdob3N0KCkgOiAnTicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJlYWsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFrKSBnaG9zdC5wdXNoKHN0cmVhayk7XG4gICAgICAgIGlmIChnaG9zdC5sZW5ndGggPT09IDAgJiYgIXRoaXMuZ2V0UGFzcygpKVxuICAgICAgICAgICAgZ2hvc3QucHVzaCgnWicpO1xuICAgICAgICByZXR1cm4gJ3IoJytnaG9zdC5qb2luKCcsJykrJyknO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBAZGVzYyByZXR1cm5zIGEgcGxhaW4gc2VyaWFsaXphYmxlIG9iamVjdFxuICAgICAqICBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZ2V0Q291bnQoKTtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaTw9bjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXREZXRhaWxzKGkpO1xuICAgICAgICAgICAgLy8gc3RyaXAgZXh0cmEga2V5c1xuICAgICAgICAgICAgZm9yKCBsZXQga2V5IGluIG5vZGUgKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVba2V5XSA9PT0gdW5kZWZpbmVkIHx8IChBcnJheS5pc0FycmF5KG5vZGVba2V5XSkgJiYgbm9kZVtrZXldLmxlbmd0aCA9PT0gMCkpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlW2tleV07XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGV0YWlscy5wdXNoKG5vZGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcGFzczogIHRoaXMuZ2V0UGFzcygpLFxuICAgICAgICAgICAgY291bnQ6IHRoaXMuZ2V0Q291bnQoKSxcbiAgICAgICAgICAgIHRpdGxlOiB0aGlzLmdldFRpdGxlKCksXG4gICAgICAgICAgICBkZXRhaWxzLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUYXAoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgQGRlc2MgUmV0dXJucyByZXBvcnQgc3RyaW5naWZpZWQgYXMgVEFQIGZvcm1hdFxuICAgICAqICBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldFRhcChuKSB7XG4gICAgICAgIGNvbnN0IHRhcCA9IG4gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0VGFwTGluZXMoKSA6IHRoaXMuZ2V0VGFwRW50cnkobik7XG4gICAgICAgIHRhcC5wdXNoKCcnKTtcbiAgICAgICAgcmV0dXJuIHRhcC5qb2luKCdcXG4nKTtcbiAgICB9XG5cbiAgICBnZXRUYXBMaW5lcyhuKSB7XG4gICAgICAgIC8vIFRBUCBmb3Igbm93LCB1c2UgYW5vdGhlciBmb3JtYXQgbGF0ZXIgYmVjYXVzZSBcInBlcmwgaXMgc2NhcnlcIlxuICAgICAgICBjb25zdCB0YXAgPSBbICcxLi4nK3RoaXMuX2NvdW50IF07XG4gICAgICAgIGlmICh0aGlzLmdldFRpdGxlKCkpXG4gICAgICAgICAgICB0YXAucHVzaCgnIyAnK3RoaXMuZ2V0VGl0bGUoKSk7XG4gICAgICAgIC8vIFRPRE8gaW5mb1swXVxuICAgICAgICBjb25zdCBwcmVmYWNlID0gdGhpcy5nZXREZXRhaWxzKDApO1xuICAgICAgICB0YXAucHVzaCggLi4ucHJlZmFjZS5pbmZvLm1hcCggcyA9PiAnIyAnK3MgKSApO1xuICAgICAgICBmb3IoIGxldCBpID0gMTsgaSA8PSB0aGlzLl9jb3VudDsgaSsrIClcbiAgICAgICAgICAgIHRhcC5wdXNoKCAuLi4gdGhpcy5nZXRUYXBFbnRyeShpKSApO1xuICAgICAgICBpZiAoIXRoaXMuZ2V0UGFzcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXRDb3VudCgpID4gMClcbiAgICAgICAgICAgICAgICB0YXAucHVzaCgnIyBGYWlsZWQgJyt0aGlzLmdldEZhaWxDb3VudCgpKycvJyt0aGlzLmdldENvdW50KCkrICcgY29uZGl0aW9ucycpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRhcC5wdXNoKCcjIE5vIGNoZWNrcyB3ZXJlIHJ1biwgY29uc2lkZXIgdXNpbmcgcGFzcygpIGlmIHRoYXRcXCdzIGRlbGliZXJhdGUnKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRhcDtcbiAgICB9XG5cbiAgICBnZXRUYXBFbnRyeShuKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0eXBlb2YobikgPT09ICdvYmplY3QnID8gbiA6IHRoaXMuZ2V0RGV0YWlscyhuKTtcbiAgICAgICAgY29uc3QgdGFwID0gW107XG4gICAgICAgIGlmIChkYXRhLm5lc3RlZCkge1xuICAgICAgICAgICAgdGFwLnB1c2goICcjIHN1YmNvbnRyYWN0OicrKGRhdGEubmFtZT8nICcrZGF0YS5uYW1lOicnKSApO1xuICAgICAgICAgICAgdGFwLnB1c2goIC4uLiBkYXRhLm5lc3RlZC5nZXRUYXBMaW5lcygpLm1hcCggcyA9PiAnICAgICcrcyApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5wZW5kaW5nKSB7XG4gICAgICAgICAgICB0YXAucHVzaCggJ3BlbmRpbmcgJytkYXRhLm4rJyA8Li4uPicgKTtcbiAgICAgICAgICAgIHJldHVybiB0YXA7XG4gICAgICAgIH1cbiAgICAgICAgdGFwLnB1c2goKGRhdGEucGFzcz8nJzonbm90ICcpICsgJ29rICcgKyBkYXRhLm5cbiAgICAgICAgICAgICsgKGRhdGEubmFtZSA/ICcgLSAnK2RhdGEubmFtZSA6ICcnKSk7XG4gICAgICAgIGlmICghZGF0YS5wYXNzKVxuICAgICAgICAgICAgdGFwLnB1c2goJyMgQ29uZGl0aW9uJysoZGF0YS5jb25kID8gJyAnK2RhdGEuY29uZCA6ICcnKSsnIGZhaWxlZCBhdCAnK2RhdGEud2hlcmUpO1xuICAgICAgICB0YXAucHVzaCguLi5kYXRhLmV2aWRlbmNlLm1hcChzPT4nIyAnK3MpKTtcbiAgICAgICAgdGFwLnB1c2goLi4uZGF0YS5pbmZvLm1hcChzPT4nIyAnK3MpKTtcbiAgICAgICAgcmV0dXJuIHRhcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiAgIEBkZXNjIFJldHVybnMgZGV0YWlsZWQgcmVwb3J0IG9uIGEgc3BlY2lmaWMgY2hlY2tcbiAgICAgKiAgIEBwYXJhbSB7aW50ZWdlcn0gbiAtIGNoZWNrIG51bWJlciwgbXVzdCBiZSA8PSBnZXRDb3VudCgpXG4gICAgICogICBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldERldGFpbHMobikge1xuICAgICAgICAvLyBUT0RPIHZhbGlkYXRlIG5cblxuICAgICAgICAvLyB1Z2x5IGJ1dCB3aGF0IGNhbiBJIGRvXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG46ICAgIDAsXG4gICAgICAgICAgICAgICAgaW5mbzogdGhpcy5faW5mb1swXSB8fCBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZXZpZGVuY2UgPSB0aGlzLl9ldmlkZW5jZVtuXTtcbiAgICAgICAgaWYgKGV2aWRlbmNlICYmICFBcnJheS5pc0FycmF5KGV2aWRlbmNlKSlcbiAgICAgICAgICAgIGV2aWRlbmNlID0gW2V2aWRlbmNlXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbjogICAgICAgIG4sXG4gICAgICAgICAgICBuYW1lOiAgICAgdGhpcy5fZGVzY3Jbbl0gfHwgJycsXG4gICAgICAgICAgICBwYXNzOiAgICAgIWV2aWRlbmNlLFxuICAgICAgICAgICAgZXZpZGVuY2U6IGV2aWRlbmNlIHx8IFtdLFxuICAgICAgICAgICAgd2hlcmU6ICAgIHRoaXMuX3doZXJlW25dLFxuICAgICAgICAgICAgY29uZDogICAgIHRoaXMuX2NvbmROYW1lW25dLFxuICAgICAgICAgICAgaW5mbzogICAgIHRoaXMuX2luZm9bbl0gfHwgW10sXG4gICAgICAgICAgICBuZXN0ZWQ6ICAgdGhpcy5fbmVzdGVkW25dLFxuICAgICAgICAgICAgcGVuZGluZzogIHRoaXMuX3BlbmRpbmcuaGFzKG4pLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqICBAZGVzYyBDb252ZXJ0IHJlcG9ydCB0byBhbiBBc3NlcnRpb25FcnJvciAoaWYgYXZhaWxhYmxlKSBvciBqdXN0IEVycm9yLlxuICAgICAqICBAcGFyYW0ge251bWJlcn0gW25dIE51bWJlciBvZiBjaGVjayB0byBjb252ZXJ0IHRvIGV4Y2VwdGlvbi5cbiAgICAgKiAgQ3VycmVudCBlcnJvciBmb3JtYXQgaXMgVEFQLCB0aGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cbiAgICAgKiAgSWYgMCBvciB1bnNwZWNpZmllZCwgY29udmVydCB0aGUgd2hvbGUgcmVwb3J0LlxuICAgICAqICBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gICAgICogIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5wYXNzIElmIGZhbHNlICh0aGUgZGVmYXVsdCksIHJldHVybiBub3RoaW5nXG4gICAgICogIGlmIHRoZSByZXBvcnQgaXMgcGFzc2luZy5cbiAgICAgKiAgQHJldHVybnMge0Vycm9yfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXRFcnJvcihuLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgLy8gbm8gZW50cnkgZ2l2ZW5cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5wYXNzICYmIHRoaXMuZ2V0UGFzcygpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgcmV0dXJuIG1ha2VFcnJvcih7XG4gICAgICAgICAgICAgICAgYWN0dWFsOiAgIHRoaXMuZ2V0VGFwKCksXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICcnLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICB0aGlzLmdldFRpdGxlKCksXG4gICAgICAgICAgICAgICAgb3BlcmF0b3I6ICdjb250cmFjdCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBkYXRhID0gdHlwZW9mIG4gPT09ICdvYmplY3QnID8gbiA6IHRoaXMuZ2V0RGV0YWlscyhuKTtcblxuICAgICAgICAvLyBubyBlcnJvclxuICAgICAgICBpZiAoIW9wdGlvbnMucGFzcyAmJiBkYXRhLnBhc3MpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgcmV0dXJuIG1ha2VFcnJvcih7XG4gICAgICAgICAgICBhY3R1YWw6ICAgdGhpcy5nZXRUYXBFbnRyeShkYXRhKS5qb2luKCdcXG4nKSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiAnJyxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICBkYXRhLm5hbWUsXG4gICAgICAgICAgICBvcGVyYXRvcjogZGF0YS5jb25kLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBnZXRUaHJvd24obiwgb3B0aW9ucz17fSkge1xuICAgICAgICAvLyBUT0RPIHJlbmFtZSB0byBqdXN0IHRocm93P1xuICAgICAgICBjb25zdCBlcnIgPSB0aGlzLmdldEVycm9yKG4sIG9wdGlvbnMpO1xuICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cblxuLy8gdGhpcyBpcyBmb3Igc3R1ZmYgbGlrZSBgb2JqZWN0IGZvbyA9IHtcImZvb1wiOjQyfWBcbi8vIHdlIGRvbid0IHdhbnQgdGhlIGV4cGxhbmF0aW9uIHRvIGJlIHF1b3RlZCFcbmZ1bmN0aW9uIF9leHBsYWluKCBpdGVtLCBkZXB0aCApIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnIClcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgcmV0dXJuIGV4cGxhaW4oIGl0ZW0sIGRlcHRoICk7XG59O1xuXG5SZXBvcnQucHJvdG90eXBlLmV4cGxhaW4gPSBleHBsYWluOyAvLyBhbHNvIG1ha2UgYXZhaWxhYmxlIHZpYSByZXBvcnRcblxuLyoqXG4gKiAgQGRlc2MgQ3JlYXRlIG5ldyBjaGVjayBtZXRob2QgYXZhaWxhYmxlIHZpYSBhbGwgUmVwb3J0IGluc3RhbmNlc1xuICogIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIG5ldyBjb25kaXRpb24uXG4gKiAgTXVzdCBub3QgYmUgcHJlc2VudCBpbiBSZXBvcnQgYWxyZWFkeSwgYW5kIHNob3VsZCBOT1Qgc3RhcnQgd2l0aFxuICogIGdldC4uLiwgc2V0Li4uLCBvciBhZGQuLi4gKHRoZXNlIGFyZSByZXNlcnZlZCBmb3IgUmVwb3J0IGl0c2VsZilcbiAqICBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25maWd1cmluZyB0aGUgY2hlY2sncyBoYW5kbGluZyBvZiBhcmd1bWVudHNcbiAqICBAcGFyYW0ge2ludGVnZXJ9IG9wdGlvbnMuYXJncyBUaGUgcmVxdWlyZWQgbnVtYmVyIG9mIGFyZ3VtZW50c1xuICogIEBwYXJhbSB7aW50ZWdlcn0gW29wdGlvbnMubWluQXJnc10gTWluaW11bSBudW1iZXIgb2YgYXJndW1lbnQgKGRlZmF1bHRzIHRvIGFyZ3MpXG4gKiAgQHBhcmFtIHtpbnRlZ2VyfSBbb3B0aW9ucy5tYXhBcmdzXSBNYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudCAoZGVmYXVsdHMgdG8gYXJncylcbiAqICBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmhhc09wdGlvbnNdIElmIHRydWUsIGFuIG9wdGlvbmFsIG9iamVjdFxuY2FuIGJlIHN1cHBsaWVkIGFzIGxhc3QgYXJndW1lbnQuIEl0IHdvbid0IGludGVyZmVyZSB3aXRoIGRlc2NyaXB0aW9uLlxuICogIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZnVuXSBUaGUgbGFzdCBhcmd1bWVudCBpcyBhIGNhbGxiYWNrXG4gKiAgQHBhcmFtIHtGdW5jdGlvbn0gaW1wbGVtZW50YXRpb24gLSBhIGNhbGxiYWNrIHRoYXQgdGFrZXMge2FyZ3N9IGFyZ3VtZW50c1xuICogIGFuZCByZXR1cm5zIGEgZmFsc2V5IHZhbHVlIGlmIGNvbmRpdGlvbiBwYXNzZXNcbiAqICAoXCJub3RoaW5nIHRvIHNlZSBoZXJlLCBtb3ZlIGFsb25nXCIpLFxuICogIG9yIGV2aWRlbmNlIGlmIGl0IGZhaWxzXG4gKiAgKGUuZy4gdHlwaWNhbGx5IGEgZ290L2V4cGVjdGVkIGRpZmYpLlxuICovXG5jb25zdCBzZWVuID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gYWRkQ29uZGl0aW9uIChuYW1lLCBvcHRpb25zLCBpbXBsKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25kaXRpb24gbmFtZSBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgaWYgKG5hbWUubWF0Y2goL14oX3xnZXRbX0EtWl18c2V0W19BLVpdKS8pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmRpdGlvbiBuYW1lIG11c3Qgbm90IHN0YXJ0IHdpdGggZ2V0Xywgc2V0Xywgb3IgXycpO1xuICAgIC8vIFRPRE8gbXVzdCBkbyBzb21ldGhpbmcgYWJvdXQgbmFtZSBjbGFzaGVzLCBidXQgbGF0ZXJcbiAgICAvLyBiZWNhdXNlIGV2YWwgaW4gYnJvd3NlciBtYXkgKGtpbmQgb2YgbGVnaW1pdGVseSkgb3ZlcnJpZGUgY29uZGl0aW9uc1xuICAgIGlmICghc2Vlbi5oYXMobmFtZSkgJiYgUmVwb3J0LnByb3RvdHlwZVtuYW1lXSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZXRob2QgYWxyZWFkeSBleGlzdHMgaW4gUmVwb3J0OiAnK25hbWUpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIG9wdGlvbnMnKTtcbiAgICBpZiAodHlwZW9mIGltcGwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGltcGxlbWVudGF0aW9uJyk7XG5cbiAgICBjb25zdCBtaW5BcmdzICAgID0gb3B0aW9ucy5taW5BcmdzIHx8IG9wdGlvbnMuYXJncztcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWluQXJncykgfHwgbWluQXJncyA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJncy9taW5BcmdzIG11c3QgYmUgbm9ubmVnYXRpdmUgaW50ZWdlcicpO1xuICAgIGNvbnN0IG1heEFyZ3MgICAgPSBvcHRpb25zLm1heEFyZ3MgfHwgb3B0aW9ucy5hcmdzIHx8IEluZmluaXR5O1xuICAgIGlmIChtYXhBcmdzICE9PSBJbmZpbml0eSAmJiAoIU51bWJlci5pc0ludGVnZXIobWluQXJncykgfHwgbWF4QXJncyA8IG1pbkFyZ3MpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21heEFyZ3MgbXVzdCBiZSBpbnRlZ2VyIGFuZCBncmVhdGVyIHRoYW4gbWluQXJncywgb3IgSW5maW5pdHknKTtcbiAgICBjb25zdCBkZXNjckZpcnN0ICAgID0gb3B0aW9ucy5kZXNjckZpcnN0IHx8IG9wdGlvbnMuZnVuIHx8IG1heEFyZ3MgPiAxMDtcbiAgICBjb25zdCBoYXNPcHRpb25zICAgID0gISFvcHRpb25zLmhhc09wdGlvbnM7XG4gICAgY29uc3QgbWF4QXJnc1JlYWwgICA9IG1heEFyZ3MgKyAoaGFzT3B0aW9ucyA/IDEgOiAwKTtcblxuICAgIC8vIFRPRE8gYWxlcnQgdW5rbm93biBvcHRpb25zXG5cbiAgICAvLyBUT0RPIHRoaXMgY29kZSBpcyBjbHV0dGVyZWQsIHJld3JpdGVcbiAgICBjb25zdCBjb2RlID0gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBjb25zdCBkZXNjciA9IGRlc2NyRmlyc3RcbiAgICAgICAgICAgID8gYXJncy5zaGlmdCgpXG4gICAgICAgICAgICA6ICggKGFyZ3MubGVuZ3RoID4gbWF4QXJncyAmJiB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aC0xXSA9PT0gJ3N0cmluZycpID8gYXJncy5wb3AoKSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IG1heEFyZ3NSZWFsIHx8IGFyZ3MubGVuZ3RoIDwgbWluQXJncylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZGl0aW9uICcrbmFtZSsnIG11c3QgaGF2ZSAnK21pbkFyZ3MrJy4uJyttYXhBcmdzUmVhbCsnIGFyZ3VtZW50cyAnKTsgLy8gVE9ET1xuXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLm5leHQoKTsgLy8gVE9ETyBjYWxsIGl0IGFkdmFuY2UoKSBvciBzbXRoLlxuICAgICAgICBjb25zdCBldmlkZW5jZSA9IGltcGwoIC4uLmFyZ3MgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0UmVzdWx0KCBuLCBldmlkZW5jZSwgZGVzY3IsIG5hbWUgKTtcbiAgICB9O1xuXG4gICAgc2Vlbi5hZGQobmFtZSk7XG4gICAgUmVwb3J0LnByb3RvdHlwZVtuYW1lXSA9IGNvZGU7XG59XG5cbi8qKlxuICogICBAZnVuY3Rpb24gY2hlY2tcbiAqICAgQG1lbWJlck9mIFJlcG9ydFxuICogICBAcGFyYW0gZXZpZGVuY2UgSWYgZmFsc2UsIHRoZSBjaGVjayBpcyBhc3N1bWVkIHRvIHBhc3MuXG4gKiAgIEEgdHJ1ZSB2YWx1ZSBtZWFucyB0aGUgY2hlY2sgZmFpbGVkLlxuICogICBAcGFyYW0ge3N0cmluZ30gW2Rlc2NyaXB0aW9uXVxuICogICBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICovXG5cbi8vIHRoZXNlIGNvbmRpdGlvbnMgY291bGQgYmUgdW5kZXIgdGhlIGNvbmRpdGlvbiBsaWJyYXJ5XG4vLyBidXQgd2UnbGwgbmVlZCB0aGVtIHRvIHZlcmlmeSB0aGUgUmVwb3J0IGNsYXNzIGl0c2VsZi5cblxuYWRkQ29uZGl0aW9uKFxuICAgICdjaGVjaycsXG4gICAge2FyZ3M6MX0sXG4gICAgeD0+eFxuKTtcbmFkZENvbmRpdGlvbihcbiAgICAncGFzcycsXG4gICAge2FyZ3M6MH0sXG4gICAgKCk9PjBcbik7XG5hZGRDb25kaXRpb24oXG4gICAgJ2ZhaWwnLFxuICAgIHthcmdzOjB9LFxuICAgICgpPT4nZmFpbGVkIGRlbGliZXJhdGVseSdcbik7XG5hZGRDb25kaXRpb24oXG4gICAgJ2VxdWFsJyxcbiAgICB7YXJnczoyfSxcbiAgICAoYSxiKSA9PiBhID09PSBiID8gMCA6IFsgbG9nLmdvdChleHBsYWluKGEpKSwgbG9nLmV4cChleHBsYWluKGIpKSBdXG4pO1xuYWRkQ29uZGl0aW9uKFxuICAgICdtYXRjaCcsXG4gICAge2FyZ3M6Mn0sXG4gICAgKGEscmV4KSA9PiAoJycrYSkubWF0Y2gocmV4KSA/IDAgOiBbXG4gICAgICAgIGxvZy5nb3QoICdleHBlY3RlZCAnK2V4cGxhaW4oJycrYSkgKSwgLy8gZXhwbGFpbiBvbmx5IHRvIHF1b3RlIGFcbiAgICAgICAgbG9nLmV4cCggJ3RvIG1hdGNoICcrcmV4ICksXG4gICAgXVxuKTtcbmFkZENvbmRpdGlvbihcbiAgICAnbmVzdGVkJyxcbiAgICB7ZnVuOjEsbWluQXJnczoxfSxcbiAgICAoLi4uYXJncykgPT4gbmV3IFJlcG9ydCgpLnJ1biguLi5hcmdzKS5kb25lKClcbik7XG5cbi8qKlxuICogICBAZXhwb3J0cyBSZXBvcnRcbiAqICAgQGV4cG9ydHMgcmVwb3J0XG4gKiAgIEBleHBvcnRzIGFkZENvbmRpdGlvblxuICogICBAZXhwb3J0cyBleHBsYWluXG4gKi9cblxuLy8gVE9ETyByZW5hbWUgbG9nIHRvIHNvbWV0aGluZyBiZXR0ZXJcblxubW9kdWxlLmV4cG9ydHMgPSB7IFJlcG9ydCwgYWRkQ29uZGl0aW9uLCBleHBsYWluLCBsb2cgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBBbm5vdGF0ZWRTZXQgfSA9IHJlcXVpcmUoICcuL3V0aWwvYW5ub3RhdGVkLXNldC5qcycgKTtcblxuLyogRGV0ZXJtaW5lIG4tdGggY2FsbGVyIHVwIHRoZSBzdGFjayAqL1xuLyogSW5zcGlyZWQgYnkgUGVybCdzIENhcnAgbW9kdWxlICovXG5jb25zdCBpblN0YWNrID0gLyhbXjpcXHMoKV0rOlxcZCsoPzo6XFxkKyk/KVxcVyooXFxufCQpL2c7XG5cbi8qKlxuICogIEBwdWJsaWNcbiAqICBAZnVuY3Rpb25cbiAqICBAZGVzYyBSZXR1cm5zIHNvdXJjZSBwb3NpdGlvbiBuIGZyYW1lcyB1cCB0aGUgc3RhY2tcbiAqICBAZXhhbXBsZVxuICogIFwiL2Zvby9iYXIuanM6MjU6MTFcIlxuICogIEBwYXJhbSB7aW50ZWdlcn0gZGVwdGggSG93IG1hbnkgZnJhbWVzIHRvIHNraXBcbiAqICBAcmV0dXJucyB7c3RyaW5nfSBzb3VyY2UgZmlsZSwgbGluZSwgYW5kIGNvbHVtbiwgc2VwYXJhdGVkIGJ5IGNvbG9uLlxuICovXG5mdW5jdGlvbiBjYWxsZXJJbmZvKG4pIHtcbiAgICAvKiBhIHRlcnJpYmxlIHJleCB0aGF0IGJhc2ljYWxseSBzZWFyY2hlcyBmb3IgZmlsZS5qczpubm46bm5uIHNldmVyYWwgdGltZXMqL1xuICAgIHJldHVybiAobmV3IEVycm9yKCkuc3RhY2subWF0Y2goaW5TdGFjaylbbisxXS5yZXBsYWNlKC9cXG4kLywgJycpIHx8ICcnKVxufVxuXG4vKipcbiAqICBAcHVibGljXG4gKiAgQGZ1bmN0aW9uXG4gKiAgQGRlc2MgU3RyaW5naXJ5IG9iamVjdHMgcmVjdXJzaXZlbHkgd2l0aCBsaW1pdGVkIGRlcHRoXG4gKiAgYW5kIGNpcmN1bGFyIHJlZmVyZW5jZSB0cmFja2luZy5cbiAqICBHZW5lcmFsbHkgSlNPTi5zdHJpbmdpZnkgaXMgdXNlZCBhcyByZWZlcmVuY2U6XG4gKiAgc3RyaW5ncyBhcmUgZXNjYXBlZCBhbmQgZG91YmxlLXF1b3RlZDsgbnVtYmVycywgYm9vbGVhbiwgYW5kIG51bGxzIGFyZVxuICogIHN0cmluZ2lmaWVkIFwiYXMgaXNcIjsgb2JqZWN0cyBhbmQgYXJyYXlzIGFyZSBkZXNjZW5kZWQgaW50by5cbiAqICBUaGUgZGlmZmVyZW5jZXMgZm9sbG93OlxuICogIHVuZGVmaW5lZCBpcyByZXBvcnRlZCBhcyAnPHVuZGVmPicuXG4gKiAgT2JqZWN0cyB0aGF0IGhhdmUgY29uc3RydWN0b3JzIGFyZSBwcmVmaXhlZCB3aXRoIGNsYXNzIG5hbWVzLlxuICogIE9iamVjdCBhbmQgYXJyYXkgY29udGVudCBpcyBhYmJyZXZpYXRlZCBhcyBcIi4uLlwiIGFuZCBcIkNpcmN1bGFyXCJcbiAqICBpbiBjYXNlIG9mIGRlcHRoIGV4aGF1c3Rpb24gYW5kIGNpcmN1bGFyIHJlZmVyZW5jZSwgcmVzcGVjdGl2ZWx5LlxuICogIEZ1bmN0aW9ucyBhcmUgbmFpdmVseSBzdHJpbmdpZmllZC5cbiAqICBAcGFyYW0ge0FueX0gdGFyZ2V0IE9iamVjdCB0byBzZXJpYWxpemUuXG4gKiAgQHBhcmFtIHtpbnRlZ2VyfSBkZXB0aD0zIERlcHRoIGxpbWl0LlxuICogIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGV4cGxhaW4oIGl0ZW0sIGRlcHRoPTMsIG9wdGlvbnM9e30sIHBhdGg9JyQnLCBzZWVuPW5ldyBBbm5vdGF0ZWRTZXQoKSApIHtcbiAgICAvLyBzaW1wbGUgdHlwZXNcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoaXRlbSk7IC8vIGRvbid0IHdhbnQgdG8gc3BlbmQgdGltZSBxb3V0aW5nXG4gICAgaWYgKHR5cGVvZiBpdGVtID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgaXRlbSA9PT0gJ2Jvb2xlYW4nIHx8IGl0ZW0gPT09IG51bGwpXG4gICAgICAgIHJldHVybiAnJytpdGVtO1xuICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHJldHVybiAnPHVuZGVmPic7XG4gICAgaWYgKHR5cGVvZiBpdGVtICE9PSAnb2JqZWN0JykgLy8gbWF5YmUgZnVuY3Rpb25cbiAgICAgICAgcmV0dXJuICcnK2l0ZW07IC8vIFRPRE8gZG9uJ3QgcHJpbnQgb3V0IGEgbG9uZyBmdW5jdGlvbidzIGJvZHlcblxuICAgIC8vIHJlY3Vyc2VcbiAgICBjb25zdCB3aGVyZVNlZW4gPSBzZWVuLmhhcyhpdGVtKTtcbiAgICBpZiAod2hlcmVTZWVuKSB7XG4gICAgICAgIGNvbnN0IG5vdGUgPSAnQ2lyY3VsYXI9Jyt3aGVyZVNlZW47XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW0pPydbICcrbm90ZSsnIF0nOid7ICcrbm90ZSsnIH0nO1xuICAgIH07XG4gICAgc2VlbiA9IHNlZW4uYWRkKCBpdGVtLCBwYXRoICk7IC8vIGNsb25lcyBzZWVuXG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBpZiAoZGVwdGggPCAxKVxuICAgICAgICAgICAgcmV0dXJuICdbLi4uXSc7XG4gICAgICAgIHNlZW4uYWRkKGl0ZW0pO1xuICAgICAgICAvLyBUT0RPIDx4IGVtcHR5IGl0ZW1zPlxuICAgICAgICBjb25zdCBsaXN0ID0gaXRlbS5tYXAoXG4gICAgICAgICAgICAodmFsLCBpbmRleCkgPT4gZXhwbGFpbih2YWwsIGRlcHRoLTEsIG9wdGlvbnMsIHBhdGgrJ1snK2luZGV4KyddJywgc2VlbilcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuICdbJytsaXN0LmpvaW4oJywgJykrJ10nOyAvLyBUT0RPIGNvbmZpZ3VyYWJsZSB3aGl0ZXNwYWNlXG4gICAgfVxuXG4gICAgY29uc3QgdHlwZSA9IGl0ZW0uY29uc3RydWN0b3IgJiYgaXRlbS5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGNvbnN0IHByZWZpeCA9IHR5cGUgJiYgdHlwZSAhPT0gJ09iamVjdCcgPyB0eXBlICsgJyAnIDogJyc7XG4gICAgaWYgKGRlcHRoIDwgMSlcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICd7Li4ufSc7XG4gICAgY29uc3QgbGlzdCA9IE9iamVjdC5rZXlzKGl0ZW0pLnNvcnQoKS5tYXAoIGtleSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gSlNPTi5zdHJpbmdpZnkoa2V5KTtcbiAgICAgICAgcmV0dXJuIGluZGV4K1wiOlwiK2V4cGxhaW4oaXRlbVtrZXldLCBkZXB0aC0xLCBvcHRpb25zLCBwYXRoKydbJytpbmRleCsnXScsIHNlZW4pO1xuICAgIH0pO1xuICAgIHJldHVybiBwcmVmaXggKyAneycgKyBsaXN0LmpvaW4oXCIsIFwiKSArICd9JztcblxuICAgIC8vIGR1bm5vIHdoYXQgaXQgaXMsIG1heWJlIGEgZnVuY3Rpb25cbiAgICByZXR1cm4gJycraXRlbTtcbn1cblxuLy8gTXVzdCB3b3JrIGV2ZW4gd2l0aG91dCBhc3NlcnRcbmNvbnN0IGhhc0Fzc2VydCA9IHR5cGVvZiBhc3NlcnQgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXNzZXJ0LkFzc2VydGlvbkVycm9yID09PSAnZnVuY3Rpb24nO1xuXG5jb25zdCBtYWtlRXJyb3IgPSBoYXNBc3NlcnRcbiAgICA/IGVudHJ5ID0+IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoZW50cnkpXG4gICAgOiBlbnRyeSA9PiBuZXcgRXJyb3IoIGVudHJ5LmFjdHVhbCApO1xuXG4vKipcbiAqICAgQGV4cG9ydHMgY2FsbGVySW5mb1xuICogICBAZXhwb3J0cyBleHBsYWluXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7IGNhbGxlckluZm8sIGV4cGxhaW4sIG1ha2VFcnJvciB9O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBTZWUgYWxzbyBub3RlZC1zZXQuanNcblxuY2xhc3MgQW5ub3RhdGVkU2V0IHtcbiAgICBjb25zdHJ1Y3RvcihhbGw9bmV3IFNldCgpLCBub3Rlcz1bXSkge1xuICAgICAgICB0aGlzLmFsbCAgID0gYWxsO1xuICAgICAgICB0aGlzLm5vdGVzID0gbm90ZXM7XG4gICAgfVxuICAgIGFkZCggaXRlbSwgbm90ZSApIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsLmhhcyhpdGVtKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEFubm90YXRlZFNldChcbiAgICAgICAgICAgIG5ldyBTZXQodGhpcy5hbGwpLmFkZChpdGVtKSxcbiAgICAgICAgICAgIFsgLi4udGhpcy5ub3RlcywgWyBpdGVtLCBub3RlIF0gXVxuICAgICAgICApO1xuICAgIH1cbiAgICBoYXMoIGl0ZW0gKSB7XG4gICAgICAgIGlmICghdGhpcy5hbGwuaGFzKCBpdGVtICkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvciAobGV0IHBhaXIgb2YgdGhpcy5ub3Rlcykge1xuICAgICAgICAgICAgaWYgKHBhaXJbMF0gPT09IGl0ZW0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhaXJbMV07XG4gICAgICAgIH07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd3RmLCB1bnJlYWNoYWJsZScpO1xuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgQW5ub3RhdGVkU2V0IH07XG4iXX0=
