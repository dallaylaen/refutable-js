/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst refute = __webpack_require__( /*! ./refute.js */ \"./lib/refute.js\" );\n\n\n\n\n//# sourceURL=webpack://refute/./lib/index.js?");

/***/ }),

/***/ "./lib/refute.js":
/*!***********************!*\
  !*** ./lib/refute.js ***!
  \***********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n// the core (should explain even be there?)\nconst { Report, addCondition, explain } = __webpack_require__ (/*! ./refute/report.js */ \"./lib/refute/report.js\");\n\n// TODO add eiffel-style design-by-contract\n\n// import default condition arsenal\n__webpack_require__( /*! ./refute/cond/basic.js */ \"./lib/refute/cond/basic.js\" );\n__webpack_require__( /*! ./refute/cond/array.js */ \"./lib/refute/cond/array.js\" );\n__webpack_require__( /*! ./refute/cond/deep.js */ \"./lib/refute/cond/deep.js\" );\n\nconst getReport = (...args) => new Report().run(...args).done();\n\n// Allow creating multiple parallel configurations of refute\n// e.g. one strict (throwing errors) and other lax (just debugging to console)\nfunction setup( options={}, orig ) {\n    // TODO validate options\n    const onFail = options.onFail || (rep => { throw new Error(rep.toString()) });\n\n    const refute = options.skip\n        ? ()=>{}\n        : (...args) => {\n            const ok = new Report();\n            ok.onDone( x => { if( !x.getPass() ) onFail(x, args) } );\n            ok.run(...args);\n            ok.done();\n        };\n\n    // reexport all from report.js\n    refute.Report = Report;\n    refute.explain = explain;\n    refute.addCondition = addCondition;\n\n    // shortcut to validating & returning a fresh contract\n    // TODO rename to avoid name clash with the class\n    // (eval?)\n    refute.report = getReport;\n\n    // refute.conf({...}) will generate a _new_ refute\n    refute.config = update => setup( { ...options, ...update }, refute );\n\n    // TODO this is stupid, come up with smth better\n    // when in browser, window.refute.config() updates window.refute itself\n    if (typeof window !== 'undefined' && orig === window.refute)\n        window.refute = refute;\n\n    return refute;\n}\n\nmodule.exports = setup();\n\n/**\n *   @namespace refute\n *   @desc   Functions exported by refute main module.\n */\n\n/**\n *   @public\n *   @memberOf refute\n *   @function refute\n *   @param {Any} [...list] Data to feed to the callback\n *   @param {Contract} contract A code block with checks.\n *   @returns {undefined} Return value is ignored.\n *   @throws {Error} If one or more checks are failing, an exception is thrown\n *   with details about all passing/failing checks.\n *   This action can be changed via refute.config() call.\n *\n */\n\n\n\n//# sourceURL=webpack://refute/./lib/refute.js?");

/***/ }),

/***/ "./lib/refute/cond/array.js":
/*!**********************************!*\
  !*** ./lib/refute/cond/array.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { addCondition, Report } = __webpack_require__( /*! ../report.js */ \"./lib/refute/report.js\" );\n\n/**\n *   @instance\n *   @memberOf conditions\n *   @method forEach\n *   @desc  Checks that a nested contract holds for each element of an array.\n *   @param {string} description\n *   @param {Array} array List of items.\n *   @param {Contract} nested First argument given to the callback\n *   is a Report object, and the second one is the array item in question.\n *   @returns {undefined}\n */\n\naddCondition(\n    'forEach',\n    {fun:1,args:2},\n    (list, contract) => {\n        if (!Array.isArray(list))\n            return 'Expected a list, found a '.typeof(list);\n        if (list.length < 1)\n            return 0; // auto-pass\n\n        const ok = new Report();\n        list.forEach( (item, index) => ok.nested( \"item \"+index, item, contract ) );\n        return ok.done();\n    }\n);\n\n/**\n *   @instance\n *   @memberOf conditions\n *   @method ordered\n *   @desc  Checks that a nested contract holds for each pair\n *   of adjacent element of an array (i.e. 1&2, 2&3, 3&4, ...).\n *   @param {string} description\n *   @param {Array} array List of items.\n *   @param {Contract} nested First argument given to the callback\n *   is a Report object, and the second and third ones\n *   are the array items in question.\n *   @returns {undefined}\n */\n\n// TODO this is called \"compliant chain\" but better just say here\n// \"oh we're checking element order\"\naddCondition(\n    'ordered', // TODO better name? pairwise? reduce?\n    {fun:1,args:2},\n    (list, contract) => {\n        if (!Array.isArray(list))\n            return 'Expected a list, found a '.typeof(list);\n        if (list.length < 2)\n            return 0; // auto-pass\n\n        const ok = new Report();\n        for (let n = 0; n < list.length-1; n++) {\n            ok.nested( \"items \"+n+\", \"+(n+1), list[n], list[n+1], contract);\n        }\n        return ok.done();\n    }\n);\n\n\n\n//# sourceURL=webpack://refute/./lib/refute/cond/array.js?");

/***/ }),

/***/ "./lib/refute/cond/basic.js":
/*!**********************************!*\
  !*** ./lib/refute/cond/basic.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { addCondition, report, explain } = __webpack_require__( /*! ../report.js */ \"./lib/refute/report.js\" );\nconst OK = false;\n\nconst cmpNum = {\n    '<' : (x,y)=>(x  < y),\n    '>' : (x,y)=>(x  > y),\n    '<=': (x,y)=>(x <= y),\n    '>=': (x,y)=>(x >= y),\n    '==': (x,y)=>(x === y),\n    '!=': (x,y)=>(x !== y),\n};\n\n// use != and not !== deliberately to filter out null & undefined\nconst cmpStr = {\n    '<' : (x,y)=>x != undefined && y != undefined && (''+x  < ''+y),\n    '>' : (x,y)=>x != undefined && y != undefined && (''+x  > ''+y),\n    '<=': (x,y)=>x != undefined && y != undefined && (''+x <= ''+y),\n    '>=': (x,y)=>x != undefined && y != undefined && (''+x >= ''+y),\n\n    '==': (x,y)=>x != undefined && y != undefined && (''+x === ''+y),\n    '!=': (x,y)=>((x == undefined)^(y == undefined)) || (''+x !== ''+y),\n};\n\n/**\n *   @instance\n *   @memberOf conditions\n *   @method cmpNum\n *   @desc  Checks if a relation indeed holds between arguments.\n *          See also {@link cmpStr}\n *   @param {any} arg1    First argument\n *   @param {string} operation  One of '<', '<=', '==', '!=', '>=', or '>'\n *   @param {any} arg2    Second argument\n *   @param {string} [description]\n *   @returns {undefined}\n */\n/**\n *   @instance\n *   @memberOf conditions\n *   @method cmpStr\n *   @desc  Checks if a relation indeed holds between arguments,\n *          assuming they are strings.\n *          See also {@link cmpNum}\n *   @param {any} arg1    First argument\n *   @param {string} operation  One of '<', '<=', '==', '!=', '>=', or '>'\n *   @param {any} arg2    Second argument\n *   @param {string} [description]\n *   @returns {undefined}\n */\n\naddCondition(\n    'cmpNum',\n    {args:3},\n    (x,op,y) => cmpNum[op](x,y)?0:[x,\"is not \"+op,y]\n);\naddCondition(\n    'cmpStr',\n    {args:3},\n    (x,op,y) => cmpStr[op](x,y)?0:[x,\"is not \"+op,y]\n);\n\nconst typeCheck = {\n    undefined: x => x === undefined,\n    null:      x => x === null,\n    number:    x => typeof x === 'number' && !Number.isNaN(x),\n    integer:   x => Number.isInteger(x),\n    nan:       x => Number.isNaN(x),\n    string:    x => typeof x === 'string',\n    function:  x => typeof x === 'function',\n    boolean:   x => typeof x === 'boolean',\n    object:    x => x && typeof x === 'object' && !Array.isArray(x),\n    array:     x => Array.isArray(x),\n};\nfunction typeExplain (x) {\n    if (typeof x === 'string')\n        return x;\n    if (typeof x === 'function')\n        return 'instanceof '+(x.name || x);\n};\n\n/**\n *   @instance\n *   @memberOf conditions\n *   @method type\n *   @desc  Checks that a value is of the specified type.\n *   @param {any} value    First argument\n *   @param {string|function|Array} type\n *       One of 'undefined', 'null', 'number', 'integer', 'nan', 'string',\n *       'boolean', 'object', 'array', a class, or an array containing 1 or more\n *       of the above. 'number'/'integer' don't include NaN,\n *       and 'object' doesn't include arrays.\n *       A function implies an object and an instanceof check.\n *       Array means any of the specified types (aka sum of types).\n *   @param {string} [description]\n *   @returns {undefined}\n */\naddCondition(\n    'type',\n    {args: 2},\n    (got, exp)=>{\n        if ( !Array.isArray(exp) )\n            exp = [exp];\n\n        for (let variant of exp) {\n            // known type\n            if( typeof variant === 'string' && typeCheck[variant] ) {\n                if (typeCheck[variant](got))\n                    return OK;\n                continue;\n            };\n\n            // instanceof\n            if( typeof variant === 'function' && typeof got === 'object') {\n                if( got instanceof variant )\n                    return OK;\n                continue;\n            };\n\n            // don't know what you're asking for\n            return 'unknown value type spec: '+explain(variant, 1);\n        };\n        return [\n            '- '+explain(got, 1),\n            '+ '+exp.map( typeExplain ).join(\" or \"),\n        ];\n    }\n);\n\n\n\n//# sourceURL=webpack://refute/./lib/refute/cond/basic.js?");

/***/ }),

/***/ "./lib/refute/cond/deep.js":
/*!*********************************!*\
  !*** ./lib/refute/cond/deep.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { addCondition, explain } = __webpack_require__( /*! ../report.js */ \"./lib/refute/report.js\" );\nconst { AnnotatedSet } = __webpack_require__( /*! ../util/annotated-set.js */ \"./lib/refute/util/annotated-set.js\" );\n\n/**\n *   @instance\n *   @memberOf conditions\n *   @method deepEqual\n *   @desc Compares two structures, outputs diff if differences found.\n *   @param {any} actual    First structure\n *   @param {any} expected  Structure to compare to\n *   @param {Object} [options]\n *   @param {number} options.max how many differences to output (default 5)\n *   @param {string} [description]\n *   @returns {undefined}\n */\naddCondition( 'deepEqual', {\"args\":2,hasOptions:true}, deep );\n\nfunction deep( got, exp, options={} ) {\n    if (!options.max)\n        options.max = 5;\n    options.diff = [];\n    _deep( got, exp, options );\n    if (!options.diff.length)\n        return 0;\n\n    const ret = [];\n    for (let item of options.diff) {\n        ret.push( \n            \"at \"+item[0],\n            \"- \"+(item[3] ? item[1] : explain( item[1], {depth:2} )),\n            \"+ \"+(item[3] ? item[2] : explain( item[2], {depth:2} )),\n        );\n    };\n    return ret;\n};\n\n// result is stored in options.diff=[], return value is ignored\n// if said diff exceeds max, return immediately & don't waste time\nfunction _deep( got, exp, options={}, path='$', seenL=new AnnotatedSet(), seenR=new AnnotatedSet() ) {\n    if (got === exp || options.max <= options.diff.length)\n        return;\n    if (typeof got !== typeof exp)\n        return options.diff.push( [path, got, exp ] );\n\n    // recurse by expected value - consider it more predictable\n    if (typeof exp !== 'object' || exp === null ) {\n        // non-objects - so can't descend\n        // and comparison already done at the beginnning\n        return options.diff.push( [path, got, exp ] );\n    }\n\n    // must detect loops before going down\n    const pathL = seenL.has(got);\n    const pathR = seenR.has(exp);\n    if (pathL || pathR) {\n        // Loop detected = only check topology\n        if (pathL === pathR)\n            return;\n        return options.diff.push( [\n            path + ' (circular)',\n            pathL ? 'Circular='+pathL : explain(got, {depth:2}),\n            pathR ? 'Circular='+pathR : explain(exp, {depth:2}),\n            true // don't stringify\n        ]);\n    };\n    seenL = seenL.add(got, path);\n    seenR = seenR.add(exp, path);\n\n    // compare object types\n    // (if a user is stupid enough to override constructor field, well the test\n    // would fail later anyway)\n    if (got.constructor !== exp.constructor)\n        return options.diff.push( [path, got, exp ] );\n\n    // array\n    if (Array.isArray(exp)) {\n        if (!Array.isArray(got) || got.length !== exp.length)\n            return options.diff.push( [path, got, exp ] );\n\n        for (let i = 0; i < exp.length; i++) {\n            _deep( got[i], exp[i], options, path+'['+i+']', seenL, seenR );\n            if (options.max<=options.diff.length)\n                break;\n        };\n        return;\n    };\n\n    // compare keys - +1 for exp, -1 for got, nonzero key at end means keys differ\n    const uniq = {};\n    Object.keys(exp).forEach( x => uniq[x] = 1 );\n    Object.keys(got).forEach( x => uniq[x] = (uniq[x] || 0) - 1 );\n    for (let x in uniq) {\n        if (uniq[x] !== 0)\n            return options.diff.push( [path, got, exp ] );\n    }\n    \n    // now typeof, object type, and object keys are the same.\n    // recurse.\n    for (let i in exp) {\n        _deep( got[i], exp[i], options, path+'['+explain(i)+']', seenL, seenR );\n        if (options.max<=options.diff.length)\n            break;\n    };\n    return;\n};\n\n\n\n//# sourceURL=webpack://refute/./lib/refute/cond/deep.js?");

/***/ }),

/***/ "./lib/refute/report.js":
/*!******************************!*\
  !*** ./lib/refute/report.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { callerInfo, explain } = __webpack_require__( /*! ./util.js */ \"./lib/refute/util.js\" );\n\n/**\n *   @callback Contract\n *   @desc A code block containing one or more condition checks.\n *   A check is performed by calling one of a few special methods\n *   (equal, match, deepEqual, type etc)\n *   on the Report object.\n *   Contracts may be nested using the 'nested' method which accepts\n *   another contract and records a pass/failure in the parent accordingly.q\n *   A contract is always executed to the end.\n *   @param {Report} ok An object that records check results.\n *   @param {Any} [...list] Additional parameters\n *   (e.g. data structure to be validated)\n *   @returns {void} Returned value is ignored.\n */\n\nconst version = 1.01;\n\n/**\n * @public\n * @classdesc\n * The core of the refute library, the report object contains info\n * about passing and failing conditions.\n */\nclass Report {\n    // setup\n    /**\n     *  @desc No constructor arguments supported.\n     *  Contracts may need to be set up inside callbacks _after_ creation,\n     *  hence this convention.\n     */\n    constructor() {\n        this._count     = 0;\n        this._failCount = 0;\n        this._descr     = [];\n        this._evidence  = [];\n        this._where     = [];\n        this._condName  = [];\n        this._info      = [];\n        this._nested    = [];\n        this._pending   = new Set();\n        this._onDone    = [];\n        this._done      = false;\n        // TODO add caller info about the report itself\n    }\n\n    // Setup methods follow. They must be chainable, i.e. return this.\n\n    /**\n     *   @desc Execute code when contract execution finishes.\n     *   Report object cannot be modified at this point,\n     *   and no additional checks my be present.\n     *   @param {function} callback - first argument is report in question\n     *   @returns {Report} this (chainable)\n     *   @example\n     *   report.onDone( r => { if (!r.getPass()) console.log(r.toString()) } )\n     */\n    onDone(fn) {\n        if( typeof fn !== 'function' )\n            throw new Error('onDone(): callback must be a function');\n        this._lock();\n        this._onDone.push(fn);\n        return this;\n    }\n\n    /**\n     *   @desc Execute code when contract execution finishes, if it failed.\n     *   Report object cannot be modified at this point,\n     *   and no additional checks my be present.\n     *   @param {function} callback - first argument is report in question\n     *   @returns {Report} this (chainable)\n     *   @example\n     *   report.onFail( r => console.log(r.toString()) );\n     */\n    onFail(fn) {\n        if( typeof fn !== 'function' )\n            throw new Error('onDone(): callback must be a function');\n        this._lock();\n        this._onDone.push(r => r.getPass() || fn(r));\n        return this;\n    }\n\n    // Running the contract\n    /**\n     *   @desc apply given function to a Report object, lock report afterwards.\n     *   If function is async (i.e. returns a {@link Promise}),\n     *   the report will only be done() after the promise resolves.\n     *   This is done so to ensure that all checks that await on a value\n     *   are resolved.\n     *   @param {Contract} contract The function to execute\n     *   Additional parameters may be _prepended_ to contract\n     *   and will be passed to it _after_ the Report object in question.\n     *   @returns {Report} this (chainable)\n     *   @example Basic usage\n     *   const r = new Report().run( ok => ok.equal( 'war', 'peace', '1984' ) );\n     *   r.getPass(); // false\n     *   r.getDone(); // true\n     *   r.toString();\n     *   r(\n     *      !1. 1984\n     *      - war\n     *      + peace\n     *   )\n     *\n     *   @example Passing additional arguments to callback.\n     *   // The contract body is the last argument.\n     *   new Report().run( { v: 4.2, colors: [ 'blue' ] }, (r, arg) => {\n     *       r.type( arg, 'object' );\n     *       r.type( arg.v, 'number' );\n     *       r.cmpNum( arg.v, '>=', 3.14 );\n     *       r.type( arg.colors, 'array' );\n     *   });\n     *   @example Async function\n     *   const r = new Report().run(\n     *       async ok => ok.equal( await 6*9, 42, 'fails but later' ) );\n     *   r.getPass(); // true\n     *   r.getDone(); // false\n     *   // ...wait for event loop to tick\n     *   r.getPass(); // false\n     *   r.getDone(); // true\n     */\n    run(...args) {\n        // TODO either async() should support additional args, or run() shouldn't\n        this._lock();\n        const block = args.pop();\n        if (typeof block !== 'function')\n            throw new Error('Last argument of run() must be a function, not '+typeof(block));\n        const result = block( this, ...args );\n        if (result instanceof Promise)\n            result.then( () => this.done() );\n        else\n            this.done();\n        return this;\n    }\n\n    /**\n     *   @desc apply given function (contract) to a Report object.\n     *   Multiple such contrats may be applied, and the report is not locked.\n     *   Async function are permitted but may not behave as expected.\n     *   @param {Contract} contract The function to execute\n     *   Additional parameters may be _prepended_ to contract\n     *   and will be passed to it _after_ the Report object in question.\n     *   @returns {Report} this (chainable)\n     *   @example Basic usage\n     *   const r = new Report()\n     *       .runSync( ok => ok.equal( 'war', 'peace', '1984' ) )\n     *       .runSync( ok => ok.type ( [], 'array', 'some more checks' ) )\n     *       .done();\n     */\n    runSync(...args) {\n        this._lock();\n        const block = args.pop();\n        if (typeof block !== 'function')\n            throw new Error('Last argument of run() must be a function, not '+typeof(block));\n        const result = block( this, ...args );\n        return this;\n    }\n\n    setResult (evidence, descr, condName, where) {\n        this._lock();\n        const n = ++this._count;\n        if (descr)\n            this._descr[n] = descr;\n        // pass - return ASAP\n        if (!evidence)\n            return;\n\n        // nested report needs special handling\n        if (evidence instanceof Report) {\n            this._nested[n] = evidence;\n            if (evidence.getDone()) {\n                if (evidence.getPass())\n                    return; // short-circuit if possible\n                evidence = []; // hack - failing without explanation\n            } else {\n                // nested contract is in async mode - coerce into a promise\n                const curry = evidence;\n                evidence = new Promise( done => {\n                    curry.onDone( done );\n                });\n            }\n        }\n\n        // pending - we're in async mode\n        if (evidence instanceof Promise) {\n            this._pending.add(n);\n            where = where || callerInfo(2); // must report actual caller, not then\n            evidence.then( x => {\n                this._pending.delete(n);\n                this._setResult(n, x, condName, where );\n                if (this.getDone()) {\n                    for (let i = this._onDone.length; i-->0; )\n                        this._onDone[i](this);\n                }\n            });\n            return;\n        }\n\n        return this._setResult(n, evidence, condName, where || callerInfo(2));\n    }\n\n    _setResult(n, evidence, condName, where) {\n        if (!evidence)\n            return;\n\n        // listify & stringify evidence, so that it doesn't change post-factum\n        if (!Array.isArray(evidence))\n            evidence = [ evidence ];\n        this._evidence[n] = evidence.map( x=>_explain(x, Infinity) );\n        this._where[n]    = where;\n        this._condName[n] = condName;\n        this._failCount++;\n    }\n\n    /**\n     * @desc Append an informational message to the report.\n     * Non-string values will be stringified via explain().\n     * @param {Any} message\n     * @returns {Report} chainable\n     */\n    info( ...message ) {\n        this._lock();\n        if (!this._info[this._count])\n            this._info[this._count] = [];\n        this._info[this._count].push( message.map( s=>_explain(s) ).join(\" \") );\n        return this;\n    }\n\n    /**\n     *   @desc Locks the report object, so no modifications may be made later.\n     *   Also if onDone callback(s) are present, they are executed\n     *   unless there are pending async checks.\n     *   @returns {Report} this (chainable)\n     */\n    done() {\n        if (!this._done) {\n            this._done = true;\n            if (!this._pending.size) {\n                for (let i = this._onDone.length; i-->0; )\n                    this._onDone[i](this);\n            }\n        };\n        return this;\n    }\n\n    // check if the Report object is still modifiable, throws otherwise.\n    _lock () {\n        if (this._done)\n            throw new Error('Attempt to modify a finished contract');\n    }\n\n    // Querying methods\n\n    /**\n     *   @desc  Tells whether the report is finished,\n     *          i.e. done() was called & no pending async checks.\n     *   @returns {boolean}\n     */\n    getDone() {\n        return this._done && !this._pending.size; // is it even needed?\n    }\n\n    /**\n     *   @desc Without argument returns whether the contract was fulfilled.\n     *   As a special case, if no checks were run and the contract is finished,\n     *   returns false, as in \"someone must have forgotten to execute\n     *   planned checks. Use pass() if no checks are planned.\n     *\n     *   If a parameter is given, return the status of n-th check instead.\n     *   @param {integer} n\n     *   @returns {boolean}\n     */\n    getPass(n) {\n        if (n === undefined)\n            return this._failCount === 0;\n        return (n > 0 && n <= this._count) ? !this._evidence[n] : undefined;\n    }\n\n    /**\n     *   @desc Number of checks performed.\n     *   @returns {number}\n     */\n    getCount() {\n        return this._count;\n    }\n\n    /**\n     *  @desc Whether the last check was a success.\n     *  This is just a shortcut for foo.getDetails(foo.getCount).pass\n     *  @returns {boolean}\n     */\n    last() {\n        return this._count ? !this._evidence[this._count] : undefined;\n    }\n\n    /**\n     *   @desc Number of checks failing.\n     *   @returns {number}\n     */\n    getFailCount() {\n        return this._failCount;\n    }\n\n    /**\n     *   @desc Return a string of failing/passing checks.\n     *   This may be useful for validating custom conditions.\n     *   Consecutive passing checka are represented by numbers.\n     *   A capital letter in the string represents failure.\n     *   See also {@link Report#toString toString()}\n     *   @returns {string}\n     *   @example\n     *   // 10 passing checks\n     *   \"r(10)\"\n     *   @example\n     *   // 10 checks with 1 failure in the middle\n     *   \"r(5,N,4)\"\n     *   @example\n     *   // 10 checks including a nested contract\n     *   \"r(3,r(1,N),6)\"\n     *   @example\n     *   // no checks were run - auto-fail\n     *   \"r(Z)\"\n     */\n    getGhost() {\n        const ghost = [];\n        let streak = 0;\n        for (let i=1; i <= this._count; i++) {\n            if (this._evidence[i] || this._nested[i]) {\n                if (streak) ghost.push(streak);\n                streak = 0;\n                ghost.push( this._nested[i] ? this._nested[i].getGhost() : 'N');\n            } else {\n                streak++;\n            }\n        }\n        if (streak) ghost.push(streak);\n        return 'r('+ghost.join(',')+')';\n    }\n\n    /**\n     *  @desc Returns serialized diff-like report with nesting and indentation.\n     *  Passing conditions are merked with numbers, failing are prefixed\n     *  with a bang (!).\n     *\n     *  See also {@link Report#getGhost getGhost()}\n     *  @returns {string}\n     *  @example // no checks run\n     *  const r = new Report();\n     *  r.toString();\n     *  r(\n     *  )\n     *  @example // pass\n     *  const r = new Report();\n     *  r.pass('foo bared');\n     *  r.toString();\n     *  r(\n     *      1. foo bared\n     *  )\n     *  @example // fail\n     *  const r = new Report();\n     *  r.equal('war', 'peace');\n     *  r.toString();\n     *  r(\n     *      !1.\n     *      ^ Condition equal failed at <file>:<line>:<char>\n     *      - war\n     *      + peace\n     *  )\n     */\n    toString() {\n        // TODO replace with refute.io when we buy the domain\n        return 'refute/'+version+'\\n'+this.getLines().join('\\n');\n    }\n\n    getLines(indent='') {\n        const out = [indent + 'r('];\n        const last = indent + ')';\n        indent = indent + '    ';\n\n        const pad = prefix => s => indent + prefix + ' ' + s;\n\n        if (this._info[0])\n            out.push( ...this._info[0].map( pad(';') ) );\n        for (let n = 1; n<=this._count; n++) {\n            out.push( ...this.getLinesPartial( n, indent ) );\n            if (this._info[n])\n                out.push( ...this._info[n].map( pad(';') ) );\n        };\n        out.push(last);\n        return out;\n    }\n\n    getLinesPartial(n, indent='') {\n        const out = [];\n        out.push(\n            indent\n            +(this._pending.has(n) ? '...' : (this._evidence[n] ? '!':'') )\n            +n+(this._descr[n] ? '. '+this._descr[n] : '.')\n        );\n        if( this._nested[n]) {\n            out.push( ...this._nested[n].getLines(indent) );\n        } else if( this._evidence[n] ) {\n            out.push( indent + '    ^ Condition `'+(this._condName[n] || 'check')\n                +'` failed at '+this._where[n] );\n            this._evidence[n].forEach( raw => {\n                // Handle multiline evidence\n                // TODO this is perl written in JS, rewrite more clearly\n                let[ _, prefix, s ] = raw.match( /^([-+|] )?(.*?)\\n?$/s );\n                if (!prefix) prefix = '| ';\n                if (!s.match(/\\n/)) {\n                    out.push( indent + '    ' + prefix + s );\n                } else {\n                    s.split('\\n').forEach(\n                        part => out.push( indent + '    ' + prefix + part ));\n                };\n            });\n        };\n        return out;\n    }\n\n    /**\n     *  @desc returns a plain serializable object\n     *  @returns {Object}\n     */\n    toJSON() {\n        const n = this.getCount();\n        const details = [];\n        for (let i = 0; i<=n; i++) {\n            const node = this.getDetails(i);\n            // strip extra keys\n            for( let key in node ) {\n                if (node[key] === undefined || (Array.isArray(node[key]) && node[key].length === 0))\n                    delete node[key];\n            };\n            details.push(node);\n        };\n        return {\n            pass:  this.getPass(),\n            count: this.getCount(),\n            details,\n        };\n    }\n\n    /**\n     *   @desc Returns detailed report on a specific check\n     *   @param {integer} n - check number, must be <= getCount()\n     *   @returns {object}\n     */\n    getDetails(n) {\n        // TODO validate n\n\n        // ugly but what can I do\n        if (n === 0) {\n            return {\n                n:    0,\n                info: this._info[0] || [],\n            };\n        }\n\n        let evidence = this._evidence[n];\n        if (evidence && !Array.isArray(evidence))\n            evidence = [evidence];\n\n        return {\n            n:        n,\n            name:     this._descr[n] || '',\n            pass:     !evidence,\n            evidence: evidence || [],\n            where:    this._where[n],\n            cond:     this._condName[n],\n            info:     this._info[n] || [],\n            nested:   this._nested[n],\n            pending:  this._pending.has(n),\n        };\n    }\n}\n\n// this is for stuff like `object foo = {\"foo\":42}`\n// we don't want the explanation to be quoted!\nfunction _explain( item, depth ) {\n    if (typeof item === 'string' )\n        return item;\n    return explain( item, { depth } );\n};\n\nReport.prototype.explain = explain; // also make available via report\nReport.version = version;\n\n// part of addCondition\nconst knownChecks = new Set();\n\n/**\n *  @memberOf refute\n *  @static\n *  @desc Create new check method available via all Report instances\n *  @param {string} name Name of the new condition.\n *  Must not be present in Report already, and should NOT start with\n *  get..., set..., or add... (these are reserved for Report itself)\n *  @param {Object} options Configuring the check's handling of arguments\n *  @param {integer} options.args The required number of arguments\n *  @param {integer} [options.minArgs] Minimum number of argument (defaults to args)\n *  @param {integer} [options.maxArgs] Maximum number of argument (defaults to args)\n *  @param {boolean} [options.hasOptions] If true, an optional object\ncan be supplied as last argument. It won't interfere with description.\n *  @param {boolean} [options.fun] The last argument is a callback\n *  @param {Function} implementation - a callback that takes {args} arguments\n *  and returns a falsey value if condition passes\n *  (\"nothing to see here, move along\"),\n *  or evidence if it fails\n *  (e.g. typically a got/expected diff).\n */\nfunction addCondition (name, options, impl) {\n    if (typeof name !== 'string')\n        throw new Error('Condition name must be a string');\n    if (name.match(/^(_|get[_A-Z]|set[_A-Z])/))\n        throw new Error('Condition name must not start with get_, set_, or _');\n    // TODO must do something about name clashes, but later\n    // because eval in browser may (kind of legimitely) override conditions\n    if (!knownChecks.has(name) && Report.prototype[name])\n        throw new Error('Method already exists in Report: '+name);\n    if (typeof options !== 'object')\n        throw new Error('bad options');\n    if (typeof impl !== 'function')\n        throw new Error('bad implementation');\n\n    const minArgs    = options.minArgs || options.args;\n    if (!Number.isInteger(minArgs) || minArgs < 0)\n        throw new Error('args/minArgs must be nonnegative integer');\n    const maxArgs    = options.maxArgs || options.args || Infinity;\n    if (maxArgs !== Infinity && (!Number.isInteger(minArgs) || maxArgs < minArgs))\n        throw new Error('maxArgs must be integer and greater than minArgs, or Infinity');\n    const descrFirst    = options.descrFirst || options.fun || maxArgs > 10;\n    const hasOptions    = !!options.hasOptions;\n    const maxArgsReal   = maxArgs + (hasOptions ? 1 : 0);\n\n    // TODO alert unknown options\n\n    // TODO this code is cluttered, rewrite\n    const code = function(...args) {\n        const descr = descrFirst\n            ? args.shift()\n            : ( (args.length > maxArgs && typeof args[args.length-1] === 'string') ? args.pop() : undefined);\n        if (args.length > maxArgsReal || args.length < minArgs)\n            throw new Error('Condition '+name+' must have '+minArgs+'..'+maxArgsReal+' arguments '); // TODO\n\n        return this.setResult( impl(...args), descr, name );\n    };\n\n    knownChecks.add(name);\n    Report.prototype[name] = code;\n}\n\n// The most basic conditions are defined right here\n// in order to be sure we can validate the Report class itself.\n\n/**\n *  @namespace conditions\n *  @desc Condition check library. These methods must be run on a\n *  {@link Report} object.\n */\n/**\n *   @instance\n *   @memberOf conditions\n *   @method check\n *   @desc A generic check of a condition.\n *   @param evidence If false, 0, '', or undefined, the check is assumed to pass.\n *   Otherwise it fails, and this argument will be displayed as the reason why.\n *   @param {string} [description] The reason why we care about the check.\n *   @returns {undefined}\n */\n/**\n *   @instance\n *   @memberOf conditions\n *   @method pass\n *   @desc Always passes.\n *   @param {string} [description]\n *   @returns {undefined}\n */\n/**\n *   @instance\n *   @memberOf conditions\n *   @method fail\n *   @desc Always fails with a \"failed deliberately\" message.\n *   @param {string} [description]\n *   @returns {undefined}\n */\n/**\n *   @instance\n *   @memberOf conditions\n *   @method equal\n *   @desc Checks if === holds between two values.\n *   If not, both will be stringified and displayed as a diff.\n *   See deepEqual to check nested data structures ot objects.\n *   @param {any} actual\n *   @param {any} expected\n *   @param {string} [description]\n *   @returns {undefined}\n */\n/**\n *   @instance\n *   @memberOf conditions\n *   @method match\n *   @desc Checks if a string matches a regular expression.\n *   @param {strung} actual\n *   @param {RegExp} expected\n *   @param {string} [description]\n *   @returns {undefined}\n */\n/**\n *   @instance\n *   @memberOf conditions\n *   @method nested\n *   @desc Verify a nested contract.\n *   @param {string} description\n *   @param {Contract} contract\n *   @returns {undefined}\n */\n\naddCondition(\n    'check',\n    {args:1},\n    x=>x\n);\naddCondition(\n    'pass',\n    {args:0},\n    ()=>0\n);\naddCondition(\n    'fail',\n    {args:0},\n    ()=>'failed deliberately'\n);\naddCondition(\n    'equal',\n    {args:2},\n    (a,b) => a === b ? 0 : [ '- '+explain(a), '+ ' + explain(b) ]\n);\naddCondition(\n    'match',\n    {args:2},\n    (a,rex) => (''+a).match(rex) ? 0 : [\n        'String         : '+a,\n        'Does not match : '+rex\n    ]\n);\naddCondition(\n    'nested',\n    {fun:1,minArgs:1},\n    (...args) => new Report().run(...args).done()\n);\n\nmodule.exports = { Report, addCondition, explain };\n\n\n//# sourceURL=webpack://refute/./lib/refute/report.js?");

/***/ }),

/***/ "./lib/refute/util.js":
/*!****************************!*\
  !*** ./lib/refute/util.js ***!
  \****************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst { AnnotatedSet } = __webpack_require__( /*! ./util/annotated-set.js */ \"./lib/refute/util/annotated-set.js\" );\n\n/**\n *   @namespace utilities\n *   @desc  These functions have nothing to do with refute and should\n *          ideally be in separate modules.\n */\n\n/* Determine n-th caller up the stack */\n/* Inspired by Perl's Carp module */\nconst inStack = /([^:\\s()]+:\\d+(?::\\d+)?)\\W*(\\n|$)/g;\n\n/**\n *  @public\n *  @memberOf utilities\n *  @function\n *  @desc Returns source position n frames up the stack\n *  @example\n *  \"/foo/bar.js:25:11\"\n *  @param {integer} depth How many frames to skip\n *  @returns {string} source file, line, and column, separated by colon.\n */\nfunction callerInfo(n) {\n    /* a terrible rex that basically searches for file.js:nnn:nnn several times*/\n    return (new Error().stack.match(inStack)[n+1].replace(/\\W*\\n$/, '') || '')\n}\n\n/**\n *  @public\n *  @instancR\n *  @memberOf Report\n *  @desc Stringiry objects recursively with limited depth\n *  and circular reference tracking.\n *  Generally JSON.stringify is used as reference:\n *  strings are escaped and double-quoted; numbers, boolean, and nulls are\n *  stringified \"as is\"; objects and arrays are descended into.\n *  The differences follow:\n *  undefined is reported as '<undef>'.\n *  Objects that have constructors are prefixed with class names.\n *  Object and array content is abbreviated as \"...\" and \"Circular\"\n *  in case of depth exhaustion and circular reference, respectively.\n *  Functions are naively stringified.\n *  @param {Any} target Object to serialize.\n *  @param {integer} depth=3 Depth limit.\n *  @returns {string}\n */\nfunction explain( item, options={}, path='$', seen=new AnnotatedSet() ) {\n    // simple types\n    return _explain( item, options.depth || 3, options, path, seen );\n}\n\nfunction _explain(item, depth, options, path, seen) {\n    if (typeof item === 'string')\n        return JSON.stringify(item); // don't want to spend time qouting\n    if (typeof item === 'number' || typeof item === 'boolean' || item === null)\n        return ''+item;\n    if (item === undefined) return '<undef>';\n    if (typeof item !== 'object') // maybe function\n        return ''+item; // TODO don't print out a long function's body\n\n    // recurse\n    const whereSeen = seen.has(item);\n    if (whereSeen) {\n        const note = 'Circular='+whereSeen;\n        return Array.isArray(item)?'[ '+note+' ]':'{ '+note+' }';\n    };\n    seen = seen.add( item, path ); // clones seen\n\n    if (Array.isArray(item)) {\n        if (depth < 1)\n            return '[...]';\n        seen.add(item);\n        // TODO <x empty items>\n        const list = item.map(\n            (val, index) => _explain(val, depth-1, options, path+'['+index+']', seen)\n        );\n        return '['+list.join(', ')+']'; // TODO configurable whitespace\n    }\n\n    const type = item.constructor && item.constructor.name;\n    const prefix = type && type !== 'Object' ? type + ' ' : '';\n    if (depth < 1)\n        return prefix + '{...}';\n    const list = Object.keys(item).sort().map( key => {\n        const index = JSON.stringify(key);\n        return index+\":\"+_explain(item[key], depth-1, options, path+'['+index+']', seen);\n    });\n    return prefix + '{' + list.join(\", \") + '}';\n}\n\nmodule.exports = { callerInfo, explain };\n\n\n//# sourceURL=webpack://refute/./lib/refute/util.js?");

/***/ }),

/***/ "./lib/refute/util/annotated-set.js":
/*!******************************************!*\
  !*** ./lib/refute/util/annotated-set.js ***!
  \******************************************/
/***/ ((module) => {

eval("\n\n// See also noted-set.js\n\nclass AnnotatedSet {\n    constructor(all=new Set(), notes=[]) {\n        this.all   = all;\n        this.notes = notes;\n    }\n    add( item, note ) {\n        if (this.all.has(item))\n            return this;\n        return new AnnotatedSet(\n            new Set(this.all).add(item),\n            [ ...this.notes, [ item, note ] ]\n        );\n    }\n    has( item ) {\n        if (!this.all.has( item ))\n            return;\n        for (let pair of this.notes) {\n            if (pair[0] === item)\n                return pair[1];\n        };\n        throw new Error('wtf, unreachable');\n    };\n};\n\nmodule.exports = { AnnotatedSet };\n\n\n//# sourceURL=webpack://refute/./lib/refute/util/annotated-set.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./lib/index.js");
/******/ 	
/******/ })()
;